<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>DOM 模型概述 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="/js/jquery.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="/#introduction">导论</a></li>
			
			<li><a href="/#grammar">语法</a></li>
			
			<li><a href="/#stdlib">标准库</a></li>
			
			<li><a href="/#oop">面向对象编程</a></li>
			
			<li><a href="/#advanced">语法专题</a></li>
			
			<li><a href="/#dom">DOM模型</a></li>
			
			<li><a href="/#bom">浏览器环境</a></li>
			
			<li><a href="/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> DOM模型 </a><ul class="dropdown">















<li><a href="/dom/attribute.html">属性的操作</a></li>



































<li><a href="/dom/css.html">CSS操作</a></li>



















<li><a href="/dom/document.html">document 对象</a></li>







<li><a href="/dom/element.html">Element对象</a></li>











<li><a href="/dom/event-type.html">事件种类</a></li>





<li><a href="/dom/event.html">事件模型</a></li>

































<li><a href="/dom/image.html">Image对象</a></li>



































<li><a href="/dom/mutationobserver.html">Mutation Observer API</a></li>







<li class="active"><a href="#">DOM 模型概述</a></li>















































































<li><a href="/dom/text.html">Text节点和DocumentFragment节点</a></li>































</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> DOM 模型概述</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> DOM 模型概述 </h1>

<aside class="right"><p>来自<a href="/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<h2 id="基本概念">基本概念</h2>

<h3 id="dom">DOM</h3>

<p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>

<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>

<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>

<h3 id="节点">节点</h3>

<p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>

<p>节点的类型有七种。</p>

<ul>
  <li><code class="highlighter-rouge">Document</code>：整个文档树的顶层节点</li>
  <li><code class="highlighter-rouge">DocumentType</code>：<code class="highlighter-rouge">doctype</code>标签（比如<code class="highlighter-rouge"><span class="cp">&lt;!DOCTYPE html&gt;</span></code>）</li>
  <li><code class="highlighter-rouge">Element</code>：网页的各种HTML标签（比如<code class="highlighter-rouge">&lt;body&gt;</code>、<code class="highlighter-rouge">&lt;a&gt;</code>等）</li>
  <li><code class="highlighter-rouge">Attribute</code>：网页元素的属性（比如<code class="highlighter-rouge">class="right"</code>）</li>
  <li><code class="highlighter-rouge">Text</code>：标签之间或标签包含的文本</li>
  <li><code class="highlighter-rouge">Comment</code>：注释</li>
  <li><code class="highlighter-rouge">DocumentFragment</code>：文档的片段</li>
</ul>

<p>浏览器提供一个原生的节点对象<code class="highlighter-rouge">Node</code>，上面这七种节点都继承了<code class="highlighter-rouge">Node</code>，因此具有一些共同的属性和方法。</p>

<h3 id="节点树">节点树</h3>

<p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p>

<p>浏览器原生提供<code class="highlighter-rouge">document</code>节点，代表整个文档。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span>
<span class="c1">// 整个文档树</span>
</code></pre></div></div>

<p>文档的第一层只有一个节点，就是 HTML 网页的第一个标签<code class="highlighter-rouge"><span class="nt">&lt;html&gt;</span></code>，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>

<p>除了根节点，其他节点都有三种层级关系。</p>

<ul>
  <li>父节点关系（parentNode）：直接的那个上级节点</li>
  <li>子节点关系（childNodes）：直接的下级节点</li>
  <li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>

<p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code class="highlighter-rouge">firstChild</code>（第一个子节点）和<code class="highlighter-rouge">lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code class="highlighter-rouge">nextSibling</code>（紧邻在后的那个同级节点）和<code class="highlighter-rouge">previousSibling</code>（紧邻在前的那个同级节点）属性。</p>

<h2 id="node-接口的属性">Node 接口的属性</h2>

<p>所有 DOM 节点都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>

<h3 id="nodenodetype">Node.nodeType</h3>

<p><code class="highlighter-rouge">nodeType</code>属性返回一个整数值，表示节点的类型。</p>

<pre><code class="language-javascirpt">document.nodeType // 9
</code></pre>

<p>上面代码中，文档节点的类型值为9。</p>

<p>Node 对象定义了几个常量，对应这些类型值。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">DOCUMENT_NODE</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>上面代码中，文档节点的<code class="highlighter-rouge">nodeType</code>属性等于常量<code class="highlighter-rouge">Node.DOCUMENT_NODE</code>。</p>

<p>不同节点的<code class="highlighter-rouge">nodeType</code>属性值和对应的常量如下。</p>

<ul>
  <li>文档节点（document）：9，对应常量<code class="highlighter-rouge">Node.DOCUMENT_NODE</code></li>
  <li>元素节点（element）：1，对应常量<code class="highlighter-rouge">Node.ELEMENT_NODE</code></li>
  <li>属性节点（attr）：2，对应常量<code class="highlighter-rouge">Node.ATTRIBUTE_NODE</code></li>
  <li>文本节点（text）：3，对应常量<code class="highlighter-rouge">Node.TEXT_NODE</code></li>
  <li>文档片断节点（DocumentFragment）：11，对应常量<code class="highlighter-rouge">Node.DOCUMENT_FRAGMENT_NODE</code></li>
  <li>文档类型节点（DocumentType）：10，对应常量<code class="highlighter-rouge">Node.DOCUMENT_TYPE_NODE</code></li>
  <li>注释节点（Comment）：8，对应常量<code class="highlighter-rouge">Node.COMMENT_NODE</code></li>
</ul>

<p>确定节点类型时，使用<code class="highlighter-rouge">nodeType</code>属性是常用方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">!==</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">ELEMENT_NODE</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'该节点是元素节点'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nodenodename">Node.nodeName</h3>

<p><code class="highlighter-rouge">nodeName</code>属性返回节点的名称。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'d1'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "DIV"</span>
</code></pre></div></div>

<p>上面代码中，元素节点<code class="highlighter-rouge">&lt;div&gt;</code>的<code class="highlighter-rouge">nodeName</code>属性就是大写的标签名<code class="highlighter-rouge">DIV</code>。</p>

<p>不同节点的<code class="highlighter-rouge">nodeName</code>属性值如下。</p>

<ul>
  <li>文档节点（document）：<code class="highlighter-rouge">#document</code></li>
  <li>元素节点（element）：大写的标签名</li>
  <li>属性节点（attr）：属性的名称</li>
  <li>文本节点（text）：<code class="highlighter-rouge">#text</code></li>
  <li>文档片断节点（DocumentFragment）：<code class="highlighter-rouge">#document-fragment</code></li>
  <li>文档类型节点（DocumentType）：文档的类型</li>
  <li>注释节点（Comment）：<code class="highlighter-rouge">#comment</code></li>
</ul>

<h3 id="nodenodevalue">Node.nodeValue</h3>

<p><code class="highlighter-rouge">nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>

<p>只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的<code class="highlighter-rouge">nodeValue</code>可以返回结果，其他类型的节点一律返回<code class="highlighter-rouge">null</code>。同样的，也只有这两类节点可以设置<code class="highlighter-rouge">nodeValue</code>属性的值，其他类型的节点设置无效。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'d1'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// null</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeValue</span> <span class="c1">// "hello world"</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">div</code>是元素节点，<code class="highlighter-rouge">nodeValue</code>属性返回<code class="highlighter-rouge">null</code>。<code class="highlighter-rouge">div.firstChild</code>是文本节点，所以可以返回文本值。</p>

<h3 id="nodetextcontent">Node.textContent</h3>

<p><code class="highlighter-rouge">textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'divA'</span><span class="p">).</span><span class="nx">textContent</span>
<span class="c1">// This is some text</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>

<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">).</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">'&lt;p&gt;GoodBye!&lt;/p&gt;'</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码在插入文本时，会将<code class="highlighter-rouge">&lt;p&gt;</code>标签解释为文本，而不会当作标签处理。</p>

<p>对于文本节点（text）和注释节点（comment），<code class="highlighter-rouge">textContent</code>属性的值与<code class="highlighter-rouge">nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。</p>

<p>文档节点（document）和文档类型节点（doctype）的<code class="highlighter-rouge">textContent</code>属性为<code class="highlighter-rouge">null</code>。如果要读取整个文档的内容，可以使用<code class="highlighter-rouge">document.documentElement.textContent</code>。</p>

<h3 id="nodebaseuri">Node.baseURI</h3>

<p><code class="highlighter-rouge">baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当前网页的网址为</span>
<span class="c1">// http://www.example.com/index.html</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">baseURI</span>
<span class="c1">// "http://www.example.com/index.html"</span>
</code></pre></div></div>

<p>如果无法读到网页的 URL，<code class="highlighter-rouge">baseURI</code>属性返回<code class="highlighter-rouge">null</code>。</p>

<p>该属性的值一般由当前网址的 URL（即<code class="highlighter-rouge">window.location</code>属性）决定，但是可以使用 HTML 的<code class="highlighter-rouge">&lt;base&gt;</code>标签，改变该属性的值。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;base</span> <span class="na">href=</span><span class="s">"http://www.example.com/page.html"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>设置了以后，<code class="highlighter-rouge">baseURI</code>属性就返回<code class="highlighter-rouge">&lt;base&gt;</code>标签设置的值。</p>

<h3 id="nodeownerdocument">Node.ownerDocument</h3>

<p><code class="highlighter-rouge">Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code class="highlighter-rouge">document</code>对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">;</span>
<span class="nx">d</span> <span class="o">===</span> <span class="nb">document</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">document</code>对象本身的<code class="highlighter-rouge">ownerDocument</code>属性，返回<code class="highlighter-rouge">null</code>。</p>

<h3 id="nodenextsibling">Node.nextSibling</h3>

<p><code class="highlighter-rouge">Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'d1'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">div2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'d2'</span><span class="p">);</span>

<span class="nx">d1</span><span class="p">.</span><span class="nx">nextSibling</span> <span class="o">===</span> <span class="nx">d2</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">d1.nextSibling</code>就是紧跟在<code class="highlighter-rouge">d1</code>后面的同级节点<code class="highlighter-rouge">d2</code>。</p>

<p>注意，该属性还包括文本节点和评论节点。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>

<p><code class="highlighter-rouge">nextSibling</code>属性可以用来遍历所有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'div1'</span><span class="p">).</span><span class="nx">firstChild</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">el</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">nodeName</span><span class="p">);</span>
  <span class="nx">el</span> <span class="o">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码遍历<code class="highlighter-rouge">div1</code>节点的所有子节点。</p>

<h3 id="nodeprevioussibling">Node.previousSibling</h3>

<p><code class="highlighter-rouge">previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'d1'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">div2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'d2'</span><span class="p">);</span>

<span class="nx">d2</span><span class="p">.</span><span class="nx">nextSibling</span> <span class="o">===</span> <span class="nx">d1</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">d2.nextSibling</code>就是<code class="highlighter-rouge">d2</code>前面的同级节点<code class="highlighter-rouge">d1</code>。</p>

<p>注意，该属性还包括文本节点和评论节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>

<h3 id="nodeparentnode">Node.parentNode</h3>

<p><code class="highlighter-rouge">parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，通过<code class="highlighter-rouge">node.parentNode</code>属性将<code class="highlighter-rouge">node</code>节点从文档里面移除。</p>

<p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code class="highlighter-rouge">null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code class="highlighter-rouge">null</code>。</p>

<h3 id="nodeparentelement">Node.parentElement</h3>

<p><code class="highlighter-rouge">parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s1">'red'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，父元素节点的样式设定了红色。</p>

<p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code class="highlighter-rouge">parentElement</code>属性相当于把后两种父节点都排除了。</p>

<h3 id="nodefirstchildnodelastchild">Node.firstChild，Node.lastChild</h3>

<p><code class="highlighter-rouge">firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;p id="p1"&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'p1'</span><span class="p">);</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "SPAN"</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">p</code>元素的第一个子节点是<code class="highlighter-rouge">span</code>元素。</p>

<p>注意，<code class="highlighter-rouge">firstChild</code>返回的除了元素节点，还可能是文本节点或评论节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;p id="p1"&gt;</span>
<span class="c1">//   &lt;span&gt;First span&lt;/span&gt;</span>
<span class="c1">//  &lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'p1'</span><span class="p">);</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">nodeName</span> <span class="c1">// "#text"</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">p</code>元素与<code class="highlighter-rouge">span</code>元素之间有空白字符，这导致<code class="highlighter-rouge">firstChild</code>返回的是文本节点。</p>

<p><code class="highlighter-rouge">lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code class="highlighter-rouge">null</code>。用法与<code class="highlighter-rouge">firstChild</code>属性相同。</p>

<h3 id="nodechildnodes">Node.childNodes</h3>

<p><code class="highlighter-rouge">childNodes</code>属性返回一个类似数组的对象（<code class="highlighter-rouge">NodeList</code>集合），成员包括当前节点的所有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'ul'</span><span class="p">).</span><span class="nx">childNodes</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">children</code>就是<code class="highlighter-rouge">ul</code>元素的所有子节点。</p>

<p>使用该属性，可以遍历某个节点的所有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'div1'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nx">div</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">nodeType</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 10</span>
<span class="c1">// 1</span>
</code></pre></div></div>

<p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p>

<p>注意，除了元素节点，<code class="highlighter-rouge">childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code class="highlighter-rouge">NodeList</code>集合。由于<code class="highlighter-rouge">NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>

<h3 id="nodeisconnected">Node.isConnected</h3>

<p><code class="highlighter-rouge">isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">test</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">isConnected</span> <span class="c1">// false</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">isConnected</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">test</code>节点是脚本生成的节点，没有插入文档之前，<code class="highlighter-rouge">isConnected</code>属性返回<code class="highlighter-rouge">false</code>，插入之后返回<code class="highlighter-rouge">true</code>。</p>

<h2 id="node-接口的方法">Node 接口的方法</h2>

<h3 id="nodeappendchild">Node.appendChild()</h3>

<p><code class="highlighter-rouge">appendChild</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码新建一个<code class="highlighter-rouge">&lt;p&gt;</code>节点，将其插入<code class="highlighter-rouge">document.body</code>的尾部。</p>

<p>如果参数节点是 DOM 已经存在的节点，<code class="highlighter-rouge">appendChild</code>方法会将其从原来的位置，移动到新位置。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span>
  <span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'div'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'b'</span><span class="p">));</span>
</code></pre></div></div>

<p>上面代码的返回值是<code class="highlighter-rouge">&lt;b&gt;&lt;/b&gt;</code>，而不是<code class="highlighter-rouge">&lt;div&gt;&lt;/div&gt;</code>。</p>

<p>如果<code class="highlighter-rouge">appendChild</code>方法的参数是<code class="highlighter-rouge">DocumentFragment</code>节点，那么插入的是<code class="highlighter-rouge">DocumentFragment</code>的所有子节点，而不是<code class="highlighter-rouge">DocumentFragment</code>节点本身。返回值是一个空的<code class="highlighter-rouge">DocumentFragment</code>节点。</p>

<h3 id="nodehaschildnodes">Node.hasChildNodes()</h3>

<p><code class="highlighter-rouge">hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">hasChildNodes</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码表示，如果<code class="highlighter-rouge">foo</code>节点有子节点，就移除第一个子节点。</p>

<p>注意，子节点包括所有节点，哪怕节点只包含一个空格，<code class="highlighter-rouge">hasChildNodes</code>方法也会返回<code class="highlighter-rouge">true</code>。</p>

<p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p>

<ul>
  <li><code class="highlighter-rouge">node.hasChildNodes()</code></li>
  <li><code class="highlighter-rouge">node.firstChild !== null</code></li>
  <li><code class="highlighter-rouge">node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>
</ul>

<p><code class="highlighter-rouge">hasChildNodes</code>方法结合<code class="highlighter-rouge">firstChild</code>属性和<code class="highlighter-rouge">nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">DOMComb</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">hasChildNodes</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span> <span class="nx">node</span><span class="p">;</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">DOMComb</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">callback</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 用法</span>
<span class="nx">DOMComb</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>

<h3 id="nodeclonenode">Node.cloneNode()</h3>

<p><code class="highlighter-rouge">cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cloneUL</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'ul'</span><span class="p">).</span><span class="nx">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div></div>

<p>该方法有一些使用注意点。</p>

<p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code class="highlighter-rouge">addEventListener</code>方法和<code class="highlighter-rouge">on-</code>属性（即<code class="highlighter-rouge">node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>

<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code class="highlighter-rouge">Node.appendChild</code>这样的方法添加到文档之中。</p>

<p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code class="highlighter-rouge">id</code>属性（即<code class="highlighter-rouge">id="xxx"</code>）的网页元素，这时应该修改其中一个元素的<code class="highlighter-rouge">id</code>属性。如果原节点有<code class="highlighter-rouge">name</code>属性，可能也需要修改。</p>

<h3 id="nodeinsertbefore">Node.insertBefore()</h3>

<p><code class="highlighter-rouge">insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">insertedNode</span> <span class="o">=</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">newNode</span><span class="p">,</span> <span class="nx">referenceNode</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code class="highlighter-rouge">newNode</code>，第二个参数是父节点<code class="highlighter-rouge">parentNode</code>内部的一个子节点<code class="highlighter-rouge">referenceNode</code>。<code class="highlighter-rouge">newNode</code>将插在<code class="highlighter-rouge">referenceNode</code>这个子节点的前面。返回值是插入的新节点<code class="highlighter-rouge">newNode</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，新建一个<code class="highlighter-rouge">&lt;p&gt;</code>节点，插在<code class="highlighter-rouge">document.body.firstChild</code>的前面，也就是成为<code class="highlighter-rouge">document.body</code>的第一个子节点。</p>

<p>如果<code class="highlighter-rouge">insertBefore</code>方法的第二个参数为<code class="highlighter-rouge">null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">p</code>将成为<code class="highlighter-rouge">document.body</code>的最后一个子节点。这也说明<code class="highlighter-rouge">insertBefore</code>的第二个参数不能省略。</p>

<p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p>

<p>由于不存在<code class="highlighter-rouge">insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code class="highlighter-rouge">insertBefore</code>方法结合<code class="highlighter-rouge">nextSibling</code>属性模拟。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parent</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">.</span><span class="nx">nextSibling</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">parent</code>是父节点，<code class="highlighter-rouge">s1</code>是一个全新的节点，<code class="highlighter-rouge">s2</code>是可以将<code class="highlighter-rouge">s1</code>节点，插在<code class="highlighter-rouge">s2</code>节点的后面。如果<code class="highlighter-rouge">s2</code>是当前节点的最后一个子节点，则<code class="highlighter-rouge">s2.nextSibling</code>返回<code class="highlighter-rouge">null</code>，这时<code class="highlighter-rouge">s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code class="highlighter-rouge">s2</code>的后面。</p>

<p>如果要插入的节点是<code class="highlighter-rouge">DocumentFragment</code>类型，那么插入的将是<code class="highlighter-rouge">DocumentFragment</code>的所有子节点，而不是<code class="highlighter-rouge">DocumentFragment</code>节点本身。返回值将是一个空的<code class="highlighter-rouge">DocumentFragment</code>节点。</p>

<h3 id="noderemovechild">Node.removeChild()</h3>

<p><code class="highlighter-rouge">removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'A'</span><span class="p">);</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码移除了<code class="highlighter-rouge">divA</code>节点。注意，这个方法是在<code class="highlighter-rouge">divA</code>的父节点上调用的，不是在<code class="highlighter-rouge">divA</code>上调用的。</p>

<p>下面是如何移除当前节点的所有子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'top'</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>

<p>如果参数节点不是当前节点的子节点，<code class="highlighter-rouge">removeChild</code>方法将报错。</p>

<h3 id="nodereplacechild">Node.replaceChild()</h3>

<p><code class="highlighter-rouge">replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">replacedNode</span> <span class="o">=</span> <span class="nx">parentNode</span><span class="p">.</span><span class="nx">replaceChild</span><span class="p">(</span><span class="nx">newChild</span><span class="p">,</span> <span class="nx">oldChild</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">replaceChild</code>方法接受两个参数，第一个参数<code class="highlighter-rouge">newChild</code>是用来替换的新节点，第二个参数<code class="highlighter-rouge">oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code class="highlighter-rouge">oldChild</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">divA</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'divA'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">newSpan</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'span'</span><span class="p">);</span>
<span class="nx">newSpan</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">'Hello World!'</span><span class="p">;</span>
<span class="nx">divA</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">replaceChild</span><span class="p">(</span><span class="nx">newSpan</span><span class="p">,</span> <span class="nx">divA</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码是如何将指定节点<code class="highlighter-rouge">divA</code>替换走。</p>

<h3 id="nodecontains">Node.contains()</h3>

<p><code class="highlighter-rouge">contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p>

<ul>
  <li>参数节点为当前节点。</li>
  <li>参数节点为当前节点的子节点。</li>
  <li>参数节点为当前节点的后代节点。</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码检查参数节点<code class="highlighter-rouge">node</code>，是否包含在当前文档之中。</p>

<p>注意，当前节点传入<code class="highlighter-rouge">contains</code>方法，返回<code class="highlighter-rouge">true</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nodeA</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">nodeA</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="nodecomparedocumentposition">Node.compareDocumentPosition()</h3>

<p><code class="highlighter-rouge">compareDocumentPosition</code>方法的用法，与<code class="highlighter-rouge">contains</code>方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。</p>

<table>
  <thead>
    <tr>
      <th>二进制值</th>
      <th>十进制值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>000000</td>
      <td>0</td>
      <td>两个节点相同</td>
    </tr>
    <tr>
      <td>000001</td>
      <td>1</td>
      <td>两个节点不在同一个文档（即有一个节点不在当前文档）</td>
    </tr>
    <tr>
      <td>000010</td>
      <td>2</td>
      <td>参数节点在当前节点的前面</td>
    </tr>
    <tr>
      <td>000100</td>
      <td>4</td>
      <td>参数节点在当前节点的后面</td>
    </tr>
    <tr>
      <td>001000</td>
      <td>8</td>
      <td>参数节点包含当前节点</td>
    </tr>
    <tr>
      <td>010000</td>
      <td>16</td>
      <td>当前节点包含参数节点</td>
    </tr>
    <tr>
      <td>100000</td>
      <td>32</td>
      <td>浏览器内部使用</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="mydiv"&gt;</span>
<span class="c1">//   &lt;form&gt;&lt;input id="test" /&gt;&lt;/form&gt;</span>
<span class="c1">// &lt;/div&gt;</span>

<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'mydiv'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'test'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="c1">// 20</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">div</span><span class="p">)</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p>上面代码中，节点<code class="highlighter-rouge">div</code>包含节点<code class="highlighter-rouge">input</code>，而且节点<code class="highlighter-rouge">input</code>在节点<code class="highlighter-rouge">div</code>的后面，所以第一个<code class="highlighter-rouge">compareDocumentPosition</code>方法返回<code class="highlighter-rouge">20</code>（二进制<code class="highlighter-rouge">010100</code>），第二个<code class="highlighter-rouge">compareDocumentPosition</code>方法返回<code class="highlighter-rouge">10</code>（二进制<code class="highlighter-rouge">001010</code>）。</p>

<p>由于<code class="highlighter-rouge">compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">compareDocumentPosition</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'文档结构正确'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'&lt;body&gt; 不能在 &lt;head&gt; 前面'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">compareDocumentPosition</code>的返回值与<code class="highlighter-rouge">4</code>（又称掩码）进行与运算（<code class="highlighter-rouge">&amp;</code>），得到一个布尔值，表示<code class="highlighter-rouge">&lt;head&gt;</code>是否在<code class="highlighter-rouge">&lt;body&gt;</code>前面。</p>

<h3 id="nodeisequalnodenodeissamenode">Node.isEqualNode()，Node.isSameNode()</h3>

<p><code class="highlighter-rouge">isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">isEqualNode</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">isSameNode</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">isSameNode</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre></div></div>

<h3 id="nodenormalize">Node.normalize()</h3>

<p><code class="highlighter-rouge">normailize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'div'</span><span class="p">);</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">'Part 1 '</span><span class="p">));</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s1">'Part 2 '</span><span class="p">));</span>

<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 2</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">normalize</span><span class="p">();</span>
<span class="nx">wrapper</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p>上面代码使用<code class="highlighter-rouge">normalize</code>方法之前，<code class="highlighter-rouge">wrapper</code>节点有两个毗邻的文本子节点。使用<code class="highlighter-rouge">normalize</code>方法之后，两个文本子节点被合并成一个。</p>

<p>该方法是<code class="highlighter-rouge">Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p>

<h3 id="nodegetrootnode">Node.getRootNode()</h3>

<p><code class="highlighter-rouge">getRootNode</code>方法返回当前节点所在文档的根节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">.</span><span class="nx">getRootNode</span><span class="p">()</span> <span class="o">===</span> <span class="nb">document</span> <span class="c1">// true</span>
</code></pre></div></div>

<h2 id="nodelist-接口">NodeList 接口</h2>

<p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：<code class="highlighter-rouge">NodeList</code>和<code class="highlighter-rouge">HTMLCollection</code>。</p>

<p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code class="highlighter-rouge">NodeList</code>实例或<code class="highlighter-rouge">HTMLCollection</code>实例。</p>

<h3 id="概述">概述</h3>

<p><code class="highlighter-rouge">NodeList</code>实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到<code class="highlighter-rouge">NodeList</code>实例。</p>

<ul>
  <li><code class="highlighter-rouge">Node.childNodes</code></li>
  <li><code class="highlighter-rouge">document.querySelectorAll()</code>、<code class="highlighter-rouge">document.getElementsByTagName()</code>等节点搜索方法</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span> <span class="k">instanceof</span> <span class="nx">NodeList</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">NodeList</code>实例很像数组，可以使用<code class="highlighter-rouge">length</code>属性和<code class="highlighter-rouge">forEach</code>方法。但是，它不是数组，不能使用<code class="highlighter-rouge">pop</code>或<code class="highlighter-rouge">push</code>之类数组特有的方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">children</span><span class="p">)</span> <span class="c1">// false</span>

<span class="nx">children</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 34</span>
<span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码中，NodeList 实例<code class="highlighter-rouge">children</code>不是数组，但是具有<code class="highlighter-rouge">length</code>属性和<code class="highlighter-rouge">forEach</code>方法。</p>

<p>如果<code class="highlighter-rouge">NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">nodeArr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">children</span><span class="p">);</span>
</code></pre></div></div>

<p>除了使用<code class="highlighter-rouge">forEach</code>方法遍历 NodeList 实例，还可以使用<code class="highlighter-rouge">for</code>循环。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code class="highlighter-rouge">Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>
<span class="nx">children</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 18</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">));</span>
<span class="nx">children</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 19</span>
</code></pre></div></div>

<p>上面代码中，文档增加一个子节点，NodeList 实例<code class="highlighter-rouge">children</code>的<code class="highlighter-rouge">length</code>属性就增加了1。</p>

<h3 id="nodelistprototypelength">NodeList.prototype.length</h3>

<p><code class="highlighter-rouge">length</code>属性返回 NodeList 实例包含的节点数量。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">'xxx'</span><span class="p">).</span><span class="nx">length</span>
<span class="c1">// 0</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">document.getElementsByTagName</code>返回一个 NodeList 集合。对于那些不存在的 HTML 标签，<code class="highlighter-rouge">length</code>属性返回<code class="highlighter-rouge">0</code>。</p>

<h3 id="nodelistprototypeforeach">NodeList.prototype.forEach()</h3>

<p><code class="highlighter-rouge">forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code class="highlighter-rouge">forEach</code>方法完全一致。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>
<span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">},</span> <span class="k">this</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，回调函数<code class="highlighter-rouge">f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。<code class="highlighter-rouge">forEach</code>方法的第二个参数，用于绑定回调函数内部的<code class="highlighter-rouge">this</code>，该参数可省略。</p>

<h3 id="nodelistprototypeitem">NodeList.prototype.item()</h3>

<p><code class="highlighter-rouge">item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">.</span><span class="nx">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">item(0)</code>返回第一个成员。</p>

<p>如果参数值大于实际长度，或者索引不合法（比如负数），<code class="highlighter-rouge">item</code>方法返回<code class="highlighter-rouge">null</code>。如果省略参数，<code class="highlighter-rouge">item</code>方法会报错。</p>

<p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用<code class="highlighter-rouge">item</code>方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="nodelistprototypekeysnodelistprototypevaluesnodelistprototypeentries">NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h3>

<p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code class="highlighter-rouge">for...of</code>循环遍历获取每一个成员的信息。区别在于，<code class="highlighter-rouge">keys()</code>返回键名的遍历器，<code class="highlighter-rouge">values()</code>返回键值的遍历器，<code class="highlighter-rouge">entries()</code>返回的遍历器同时包含键名和键值的信息。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">children</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// ...</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">children</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// #text</span>
<span class="c1">// &lt;script&gt;</span>
<span class="c1">// ...</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">entry</span> <span class="k">of</span> <span class="nx">children</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Array [ 0, #text ]</span>
<span class="c1">// Array [ 1, &lt;script&gt; ]</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="htmlcollection-接口">HTMLCollection 接口</h2>

<h3 id="概述-1">概述</h3>

<p><code class="highlighter-rouge">HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与<code class="highlighter-rouge">NodeList</code>接口不同，<code class="highlighter-rouge">HTMLCollection</code>没有<code class="highlighter-rouge">forEach</code>方法，只能使用<code class="highlighter-rouge">for</code>循环遍历。</p>

<p>返回<code class="highlighter-rouge">HTMLCollection</code>实例的，主要是一些<code class="highlighter-rouge">Document</code>对象的集合属性，比如<code class="highlighter-rouge">document.links</code>、<code class="highlighter-rouge">docuement.forms</code>、<code class="highlighter-rouge">document.images</code>等。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">links</span> <span class="k">instanceof</span> <span class="nx">HTMLCollection</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HTMLCollection</code>实例都是动态集合，节点的变化会实时反映在集合中。</p>

<p>如果元素节点有<code class="highlighter-rouge">id</code>或<code class="highlighter-rouge">name</code>属性，那么<code class="highlighter-rouge">HTMLCollection</code>实例上面，可以使用<code class="highlighter-rouge">id</code>属性或<code class="highlighter-rouge">name</code>属性引用该节点元素。如果没有对应的节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>

<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'pic'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nx">pic</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">document.images</code>是一个<code class="highlighter-rouge">HTMLCollection</code>实例，可以通过<code class="highlighter-rouge">&lt;img&gt;</code>元素的<code class="highlighter-rouge">id</code>属性值，从<code class="highlighter-rouge">HTMLCollection</code>实例上取到这个元素。</p>

<h3 id="htmlcollectionprototypelength">HTMLCollection.prototype.length</h3>

<p><code class="highlighter-rouge">length</code>属性返回<code class="highlighter-rouge">HTMLCollection</code>实例包含的成员数量。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">links</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 18</span>
</code></pre></div></div>

<h3 id="htmlcollectionprototypeitem">HTMLCollection.prototype.item()</h3>

<p><code class="highlighter-rouge">item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">img0</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">item(0)</code>表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。</p>

<p>如果参数值超出成员数量或者不合法（比如小于0），那么<code class="highlighter-rouge">item</code>方法返回<code class="highlighter-rouge">null</code>。</p>

<h3 id="htmlcollectionprototypenameditem">HTMLCollection.prototype.namedItem()</h3>

<p><code class="highlighter-rouge">namedItem</code>方法的参数是一个字符串，表示<code class="highlighter-rouge">id</code>属性或<code class="highlighter-rouge">name</code>属性的值，返回对应的元素节点。如果没有对应的节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span>

<span class="kd">var</span> <span class="nx">pic</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'pic'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">images</span><span class="p">.</span><span class="nx">namedItem</span><span class="p">(</span><span class="s1">'pic'</span><span class="p">)</span> <span class="o">===</span> <span class="nx">pic</span> <span class="c1">// true</span>
</code></pre></div></div>

<h2 id="parentnode-接口">ParentNode 接口</h2>

<p>节点对象除了继承 Node 接口以外，还会继承其他接口。<code class="highlighter-rouge">ParentNode</code>接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code class="highlighter-rouge">ChildNode</code>接口表示当前节点是一个子节点，提供一些相关方法。</p>

<p>如果当前节点是父节点，就会继承<code class="highlighter-rouge">ParentNode</code>接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承<code class="highlighter-rouge">ParentNode</code>接口。</p>

<h3 id="parentnodechildren">ParentNode.children</h3>

<p><code class="highlighter-rouge">children</code>属性返回一个<code class="highlighter-rouge">HTMLCollection</code>实例，成员是当前节点的所有元素子节点。该属性只读。</p>

<p>下面是遍历某个节点的所有元素子节点的示例。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意，<code class="highlighter-rouge">children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code class="highlighter-rouge">HTMLCollection</code>实例的<code class="highlighter-rouge">length</code>属性为<code class="highlighter-rouge">0</code>。</p>

<p>另外，<code class="highlighter-rouge">HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p>

<h3 id="parentnodefirstelementchild">ParentNode.firstElementChild</h3>

<p><code class="highlighter-rouge">firstElementChild</code>属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">firstElementChild</span><span class="p">.</span><span class="nx">nodeName</span>
<span class="c1">// "HTML"</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">document</code>节点的第一个元素子节点是<code class="highlighter-rouge">&lt;HTML&gt;</code>。</p>

<h3 id="parentnodelastelementchild">ParentNode.lastElementChild</h3>

<p><code class="highlighter-rouge">lastElementChild</code>属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回<code class="highlighter-rouge">null</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">lastElementChild</span><span class="p">.</span><span class="nx">nodeName</span>
<span class="c1">// "HTML"</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">document</code>节点的最后一个元素子节点是<code class="highlighter-rouge">&lt;HTML&gt;</code>（因为<code class="highlighter-rouge">document</code>只包含这一个元素子节点）。</p>

<h3 id="parentnodechildelementcount">ParentNode.childElementCount</h3>

<p><code class="highlighter-rouge">childElementCount</code>属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回<code class="highlighter-rouge">0</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">childElementCount</span> <span class="c1">// 13</span>
</code></pre></div></div>

<h3 id="parentnodeappendparentnodeprepend">ParentNode.append()，ParentNode.prepend()</h3>

<p><code class="highlighter-rouge">append</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p>

<p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>

<span class="c1">// 添加元素子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="c1">// 添加文本子节点</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">);</span>

<span class="c1">// 添加多个元素子节点</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">);</span>

<span class="c1">// 添加元素子节点和文本子节点</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">,</span> <span class="nx">p</span><span class="p">);</span>
</code></pre></div></div>

<p>注意，该方法没有返回值。</p>

<p><code class="highlighter-rouge">prepend</code>方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与<code class="highlighter-rouge">append</code>方法完全一致，也是没有返回值。</p>

<h2 id="childnode-接口">ChildNode 接口</h2>

<p>如果一个节点有父节点，那么该节点就继承了<code class="highlighter-rouge">ChildNode</code>接口。</p>

<h3 id="childnoderemove">ChildNode.remove()</h3>

<p><code class="highlighter-rouge">remove</code>方法用于从父节点移除当前节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nx">remove</span><span class="p">()</span>
</code></pre></div></div>

<p>上面代码在 DOM 里面移除了<code class="highlighter-rouge">el</code>节点。</p>

<h3 id="childnodebeforechildnodeafter">ChildNode.before()，ChildNode.after()</h3>

<p><code class="highlighter-rouge">before</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p>

<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'p'</span><span class="p">);</span>

<span class="c1">// 插入元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>

<span class="c1">// 插入文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">);</span>

<span class="c1">// 插入多个元素节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p1</span><span class="p">);</span>

<span class="c1">// 插入元素节点和文本节点</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="s1">'Hello'</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">after</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code class="highlighter-rouge">before</code>方法完全相同。</p>

<h3 id="childnodereplacewith">ChildNode.replaceWith()</h3>

<p><code class="highlighter-rouge">replaceWith</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">span</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'span'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">replaceWith</span><span class="p">(</span><span class="nx">span</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">el</code>节点将被<code class="highlighter-rouge">span</code>节点替换。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>Louis Lazaris, <a href="http://coding.smashingmagazine.com/2013/10/06/inside-the-box-with-vanilla-javascript/">Thinking Inside The Box With Vanilla JavaScript</a></li>
  <li>David Walsh, <a href="http://davidwalsh.name/classlist">HTML5 classList API</a></li>
  <li>Derek Johnson, <a href="http://html5doctor.com/the-classlist-api/">The classList API</a></li>
  <li>Mozilla Developer Network, <a href="http://davidwalsh.name/element-dataset">element.dataset API</a></li>
  <li>David Walsh, <a href="http://davidwalsh.name/element-dataset">The element.dataset API</a></li>
</ul>



</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="/introduction/license.html">版权声明</a> | last modified on 2014-05-18 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


