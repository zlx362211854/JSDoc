<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>npm模块管理器 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="/js/jquery.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="/#introduction">导论</a></li>
			
			<li><a href="/#grammar">语法</a></li>
			
			<li><a href="/#stdlib">标准库</a></li>
			
			<li><a href="/#oop">面向对象编程</a></li>
			
			<li><a href="/#advanced">语法专题</a></li>
			
			<li><a href="/#dom">DOM模型</a></li>
			
			<li><a href="/#bom">浏览器环境</a></li>
			
			<li><a href="/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> 草稿二：Node.js </a><ul class="dropdown">













<li><a href="/nodejs/assert.html">assert 模块</a></li>













<li><a href="/nodejs/basic.html">Node.js 概述</a></li>













<li><a href="/nodejs/buffer.html">Buffer对象</a></li>





<li><a href="/nodejs/child-process.html">Child Process模块</a></li>





<li><a href="/nodejs/cluster.html">Cluster模块</a></li>

























<li><a href="/nodejs/develop.html">Node应用程序开发</a></li>





<li><a href="/nodejs/dns.html">dns 模块</a></li>





















<li><a href="/nodejs/events.html">Events模块</a></li>







<li><a href="/nodejs/express.html">Express框架</a></li>









<li><a href="/nodejs/fs.html">fs 模块</a></li>



















<li><a href="/nodejs/http.html">Http模块</a></li>



















<li><a href="/nodejs/koa.html">Koa 框架</a></li>

















<li><a href="/nodejs/module.html">CommonJS规范</a></li>





<li><a href="/nodejs/mongodb.html">MongoDB的应用</a></li>







<li><a href="/nodejs/net.html">Net模块和DNS模块</a></li>









<li class="active"><a href="#">npm模块管理器</a></li>

















<li><a href="/nodejs/os.html">os模块</a></li>





<li><a href="/nodejs/packagejson.html">package.json文件</a></li>







<li><a href="/nodejs/path.html">Path模块</a></li>















<li><a href="/nodejs/process.html">process对象</a></li>











<li><a href="/nodejs/querystring.html">querystring 模块</a></li>





















<li><a href="/nodejs/stream.html">Stream接口</a></li>



























<li><a href="/nodejs/url.html">url 模块</a></li>





















</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> npm模块管理器</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> npm模块管理器 </h1>

<aside class="right"><p>来自<a href="/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<h2 id="简介">简介</h2>

<p><code class="highlighter-rouge">npm</code>有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为<a href="http://npmjs.org">npmjs.org</a>。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。</p>

<p><code class="highlighter-rouge">npm</code>不需要单独安装。在安装Node的时候，会连带一起安装<code class="highlighter-rouge">npm</code>。但是，Node附带的<code class="highlighter-rouge">npm</code>可能不是最新版本，最好用下面的命令，更新到最新版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>npm@latest <span class="nt">-g</span>
</code></pre></div></div>

<p>上面的命令中，<code class="highlighter-rouge">@latest</code>表示最新版本，<code class="highlighter-rouge">-g</code>表示全局安装。所以，命令的主干是<code class="highlighter-rouge">npm install npm</code>，也就是使用<code class="highlighter-rouge">npm</code>安装自己。之所以可以这样，是因为<code class="highlighter-rouge">npm</code>本身与Node的其他模块没有区别。</p>

<p>然后，运行下面的命令，查看各种信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 npm 命令列表</span>
<span class="nv">$ </span>npm <span class="nb">help</span>

<span class="c"># 查看各个命令的简单用法</span>
<span class="nv">$ </span>npm <span class="nt">-l</span>

<span class="c"># 查看 npm 的版本</span>
<span class="nv">$ </span>npm <span class="nt">-v</span>

<span class="c"># 查看 npm 的配置</span>
<span class="nv">$ </span>npm config list <span class="nt">-l</span>
</code></pre></div></div>

<h2 id="npm-init">npm init</h2>

<p><code class="highlighter-rouge">npm init</code>用来初始化生成一个新的<code class="highlighter-rouge">package.json</code>文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。</p>

<p>如果使用了<code class="highlighter-rouge">-f</code>（代表force）、<code class="highlighter-rouge">-y</code>（代表yes），则跳过提问阶段，直接生成一个新的<code class="highlighter-rouge">package.json</code>文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm init <span class="nt">-y</span>
</code></pre></div></div>

<h2 id="npm-set">npm set</h2>

<p><code class="highlighter-rouge">npm set</code>用来设置环境变量。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">set </span>init-author-name <span class="s1">'Your name'</span>
<span class="nv">$ </span>npm <span class="nb">set </span>init-author-email <span class="s1">'Your email'</span>
<span class="nv">$ </span>npm <span class="nb">set </span>init-author-url <span class="s1">'http://yourdomain.com'</span>
<span class="nv">$ </span>npm <span class="nb">set </span>init-license <span class="s1">'MIT'</span>
</code></pre></div></div>

<p>上面命令等于为<code class="highlighter-rouge">npm init</code>设置了默认值，以后执行<code class="highlighter-rouge">npm init</code>的时候，<code class="highlighter-rouge">package.json</code>的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的<code class="highlighter-rouge"> ~/.npmrc</code>文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行<code class="highlighter-rouge">npm config</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">set </span>save-exact <span class="nb">true</span>
</code></pre></div></div>

<p>上面命令设置加入模块时，<code class="highlighter-rouge">package.json</code>将记录模块的确切版本，而不是一个可选的版本范围。</p>

<h2 id="npm-config">npm config</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm config <span class="nb">set </span>prefix <span class="nv">$dir</span>
</code></pre></div></div>

<p>上面的命令将指定的<code class="highlighter-rouge">$dir</code>目录，设为模块的全局安装目录。如果当前有这个目录的写权限，那么运行<code class="highlighter-rouge">npm install</code>的时候，就不再需要<code class="highlighter-rouge">sudo</code>命令授权了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm config <span class="nb">set </span>save-prefix ~
</code></pre></div></div>

<p>上面的命令使得<code class="highlighter-rouge">npm install --save</code>和<code class="highlighter-rouge">npm install --save-dev</code>安装新模块时，允许的版本范围从克拉符号（<code class="highlighter-rouge">^</code>）改成波浪号（<code class="highlighter-rouge">~</code>），即从允许小版本升级，变成只允许补丁包的升级。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm config <span class="nb">set </span>init.author.name <span class="nv">$name</span>
<span class="nv">$ </span>npm config <span class="nb">set </span>init.author.email <span class="nv">$email</span>
</code></pre></div></div>

<p>上面命令指定使用<code class="highlighter-rouge">npm init</code>时，生成的<code class="highlighter-rouge">package.json</code>文件的字段默认值。</p>

<h2 id="npm-info">npm info</h2>

<p><code class="highlighter-rouge">npm info</code>命令可以查看每个模块的具体信息。比如，查看underscore模块的信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm info underscore
<span class="o">{</span> name: <span class="s1">'underscore'</span>,
  description: <span class="s1">'JavaScript\'</span>s functional programming helper library.<span class="s1">',
  '</span>dist-tags<span class="s1">': { latest: '</span>1.5.2<span class="s1">', stable: '</span>1.5.2<span class="s1">' },
  repository:
   { type: '</span>git<span class="s1">',
     url: '</span>git://github.com/jashkenas/underscore.git<span class="s1">' },
  homepage: '</span>http://underscorejs.org<span class="s1">',
  main: '</span>underscore.js<span class="s1">',
  version: '</span>1.5.2<span class="s1">',
  devDependencies: { phantomjs: '</span>1.9.0-1<span class="s1">' },
  licenses:
   { type: '</span>MIT<span class="s1">',
     url: '</span>https://raw.github.com/jashkenas/underscore/master/LICENSE<span class="s1">' },
  files:
   [ '</span>underscore.js<span class="s1">',
     '</span>underscore-min.js<span class="s1">',
     '</span>LICENSE<span class="s1">' ],
  readmeFilename: '</span>README.md<span class="s1">'}
</span></code></pre></div></div>

<p>上面命令返回一个JavaScript对象，包含了underscore模块的详细信息。这个对象的每个成员，都可以直接从info命令查询。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm info underscore description
JavaScript<span class="s1">'s functional programming helper library.

$ npm info underscore homepage
http://underscorejs.org

$ npm info underscore version
1.5.2
</span></code></pre></div></div>

<h2 id="npm-search">npm search</h2>

<p><code class="highlighter-rouge">npm search</code>命令用于搜索npm仓库，它后面可以跟字符串，也可以跟正则表达式。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm search &lt;搜索词&gt;
</code></pre></div></div>

<p>下面是一个例子。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm search node-gyp
// NAME                  DESCRIPTION
// autogypi              Autogypi handles dependencies <span class="k">for </span>node-gyp projects.
// grunt-node-gyp        Run node-gyp commands from Grunt.
// gyp-io                Temporary solution to <span class="nb">let </span>node-gyp run <span class="sb">`</span>rebuild<span class="sb">`</span> under…
// ...
</code></pre></div></div>

<h2 id="npm-list">npm list</h2>

<p><code class="highlighter-rouge">npm list</code>命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm list
</code></pre></div></div>

<p>加上global参数，会列出全局安装的模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm list <span class="nt">-global</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">npm list</code>命令也可以列出单个模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm list underscore
</code></pre></div></div>

<h2 id="npm-install">npm install</h2>

<h3 id="基本用法">基本用法</h3>

<p>Node模块采用<code class="highlighter-rouge">npm install</code>命令安装。</p>

<p>每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如<code class="highlighter-rouge">eslint</code>和<code class="highlighter-rouge">gulp</code>。“本地安装”指的是将一个模块下载到当前项目的<code class="highlighter-rouge">node_modules</code>子目录，然后只有在项目目录之中，才能调用这个模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 本地安装</span>
<span class="nv">$ </span>npm <span class="nb">install</span> &lt;package name&gt;

<span class="c"># 全局安装</span>
<span class="nv">$ </span><span class="nb">sudo </span>npm <span class="nb">install</span> <span class="nt">-global</span> &lt;package name&gt;
<span class="nv">$ </span><span class="nb">sudo </span>npm <span class="nb">install</span> <span class="nt">-g</span> &lt;package name&gt;
</code></pre></div></div>

<p><code class="highlighter-rouge">npm install</code>也支持直接输入Github代码库地址。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>git://github.com/package/path.git
<span class="nv">$ </span>npm <span class="nb">install </span>git://github.com/package/path.git#0.1.0
</code></pre></div></div>

<p>安装之前，<code class="highlighter-rouge">npm install</code>会先检查，<code class="highlighter-rouge">node_modules</code>目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p>

<p>如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用<code class="highlighter-rouge">-f</code>或<code class="highlighter-rouge">--force</code>参数。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install</span> &lt;packageName&gt; <span class="nt">--force</span>
</code></pre></div></div>

<p>如果你希望，所有模块都要强制重新安装，那就删除<code class="highlighter-rouge">node_modules</code>目录，重新执行<code class="highlighter-rouge">npm install</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-rf</span> node_modules
<span class="nv">$ </span>npm <span class="nb">install</span>
</code></pre></div></div>

<h3 id="安装不同版本">安装不同版本</h3>

<p>install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>sax@latest
<span class="nv">$ </span>npm <span class="nb">install </span>sax@0.1.1
<span class="nv">$ </span>npm <span class="nb">install </span>sax@<span class="s2">"&gt;=0.1.0 &lt;0.2.0"</span>
</code></pre></div></div>

<p>如果使用<code class="highlighter-rouge">--save-exact</code>参数，会在package.json文件指定安装模块的确切版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>readable-stream <span class="nt">--save</span> <span class="nt">--save-exact</span>
</code></pre></div></div>

<p>install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。</p>

<ul>
  <li>–save：模块名将被添加到dependencies，可以简化为参数<code class="highlighter-rouge">-S</code>。</li>
  <li>–save-dev: 模块名将被添加到devDependencies，可以简化为参数<code class="highlighter-rouge">-D</code>。</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>sax <span class="nt">--save</span>
<span class="nv">$ </span>npm <span class="nb">install </span>node-tap <span class="nt">--save-dev</span>
<span class="c"># 或者</span>
<span class="nv">$ </span>npm <span class="nb">install </span>sax <span class="nt">-S</span>
<span class="nv">$ </span>npm <span class="nb">install </span>node-tap <span class="nt">-D</span>
</code></pre></div></div>

<p>如果要安装beta版本的模块，需要使用下面的命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装最新的beta版</span>
<span class="nv">$ </span>npm <span class="nb">install</span> &lt;module-name&gt;@beta <span class="o">(</span>latest beta<span class="o">)</span>

<span class="c"># 安装指定的beta版</span>
<span class="nv">$ </span>npm <span class="nb">install</span> &lt;module-name&gt;@1.3.1-beta.3
</code></pre></div></div>

<p><code class="highlighter-rouge">npm install</code>默认会安装<code class="highlighter-rouge">dependencies</code>字段和<code class="highlighter-rouge">devDependencies</code>字段中的所有模块，如果使用<code class="highlighter-rouge">--production</code>参数，可以只安装<code class="highlighter-rouge">dependencies</code>字段的模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install</span> <span class="nt">--production</span>
<span class="c"># 或者</span>
<span class="nv">$ NODE_ENV</span><span class="o">=</span>production npm <span class="nb">install</span>
</code></pre></div></div>

<p>一旦安装了某个模块，就可以在代码中用<code class="highlighter-rouge">require</code>命令加载这个模块。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">backbone</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'backbone'</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">backbone</span><span class="p">.</span><span class="nx">VERSION</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="避免系统权限">避免系统权限</h2>

<p>默认情况下，Npm全局模块都安装在系统目录（比如<code class="highlighter-rouge">/usr/local/lib/</code>），普通用户没有写入权限，需要用到<code class="highlighter-rouge">sudo</code>命令。这不是很方便，我们可以在没有root权限的情况下，安装全局模块。</p>

<p>首先，在主目录下新建配置文件<code class="highlighter-rouge">.npmrc</code>，然后在该文件中将<code class="highlighter-rouge">prefix</code>变量定义到主目录下面。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prefix <span class="o">=</span> /home/yourUsername/npm
</code></pre></div></div>

<p>然后在主目录下新建<code class="highlighter-rouge">npm</code>子目录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> ~/npm
</code></pre></div></div>

<p>此后，全局安装的模块都会安装在这个子目录中，npm也会到<code class="highlighter-rouge">~/npm/bin</code>目录去寻找命令。</p>

<p>最后，将这个路径在<code class="highlighter-rouge">.bash_profile</code>文件（或<code class="highlighter-rouge">.bashrc</code>文件）中加入PATH变量。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>~/npm/bin:<span class="nv">$PATH</span>
</code></pre></div></div>

<h2 id="npm-updatenpm-uninstall">npm update，npm uninstall</h2>

<p><code class="highlighter-rouge">npm update</code>命令可以更新本地安装的模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 升级当前项目的指定模块</span>
<span class="nv">$ </span>npm update <span class="o">[</span>package name]

<span class="c"># 升级全局安装的模块</span>
<span class="nv">$ </span>npm update <span class="nt">-global</span> <span class="o">[</span>package name]
</code></pre></div></div>

<p>它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。</p>

<p>使用<code class="highlighter-rouge">-S</code>或<code class="highlighter-rouge">--save</code>参数，可以在安装的时候更新<code class="highlighter-rouge">package.json</code>里面模块的版本号。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 更新之前的package.json</span>
<span class="nx">dependencies</span><span class="p">:</span> <span class="p">{</span>
  <span class="nl">dep1</span><span class="p">:</span> <span class="s2">"^1.1.1"</span>
<span class="p">}</span>

<span class="c1">// 更新之后的package.json</span>
<span class="nl">dependencies</span><span class="p">:</span> <span class="p">{</span>
  <span class="nl">dep1</span><span class="p">:</span> <span class="s2">"^1.2.2"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意，从npm v2.6.1 开始，<code class="highlighter-rouge">npm update</code>只更新顶层模块，而不更新依赖的依赖，以前版本是递归更新的。如果想取到老版本的效果，要使用下面的命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nt">--depth</span> 9999 update
</code></pre></div></div>

<p><code class="highlighter-rouge">npm uninstall</code>命令，卸载已安装的模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm uninstall <span class="o">[</span>package name]

<span class="c"># 卸载全局模块</span>
<span class="nv">$ </span>npm uninstall <span class="o">[</span>package name] <span class="nt">-global</span>
</code></pre></div></div>

<h2 id="npm-run">npm run</h2>

<p><code class="highlighter-rouge">npm</code>不仅可以用于模块管理，还可以用于执行脚本。<code class="highlighter-rouge">package.json</code>文件有一个<code class="highlighter-rouge">scripts</code>字段，可以用于指定脚本命令，供<code class="highlighter-rouge">npm</code>直接调用。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"myproject"</span><span class="p">,</span>
  <span class="s2">"devDependencies"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"jshint"</span><span class="p">:</span> <span class="s2">"latest"</span><span class="p">,</span>
    <span class="s2">"browserify"</span><span class="p">:</span> <span class="s2">"latest"</span><span class="p">,</span>
    <span class="s2">"mocha"</span><span class="p">:</span> <span class="s2">"latest"</span>
  <span class="p">},</span>
  <span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"lint"</span><span class="p">:</span> <span class="s2">"jshint **.js"</span><span class="p">,</span>
    <span class="s2">"test"</span><span class="p">:</span> <span class="s2">"mocha test/"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">scripts</code>字段指定了两项命令<code class="highlighter-rouge">lint</code>和<code class="highlighter-rouge">test</code>。命令行输入<code class="highlighter-rouge">npm run-script lint</code>或者<code class="highlighter-rouge">npm run lint</code>，就会执行<code class="highlighter-rouge">jshint **.js</code>，输入<code class="highlighter-rouge">npm run-script test</code>或者<code class="highlighter-rouge">npm run test</code>，就会执行<code class="highlighter-rouge">mocha test/</code>。<code class="highlighter-rouge">npm run</code>是<code class="highlighter-rouge">npm run-script</code>的缩写，一般都使用前者，但是后者可以更好地反应这个命令的本质。</p>

<p><code class="highlighter-rouge">npm run</code>命令会自动在环境变量<code class="highlighter-rouge">$PATH</code>添加<code class="highlighter-rouge">node_modules/.bin</code>目录，所以<code class="highlighter-rouge">scripts</code>字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。</p>

<p><code class="highlighter-rouge">npm run</code>如果不加任何参数，直接运行，会列出<code class="highlighter-rouge">package.json</code>里面所有可以执行的脚本命令。</p>

<p>npm内置了两个命令简写，<code class="highlighter-rouge">npm test</code>等同于执行<code class="highlighter-rouge">npm run test</code>，<code class="highlighter-rouge">npm start</code>等同于执行<code class="highlighter-rouge">npm run start</code>。</p>

<p><code class="highlighter-rouge">npm run</code>会创建一个Shell，执行指定的命令，并临时将<code class="highlighter-rouge">node_modules/.bin</code>加入PATH变量，这意味着本地模块可以直接运行。</p>

<p>举例来说，你执行ESLint的安装命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm i eslint <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>运行上面的命令以后，会产生两个结果。首先，ESLint被安装到当前目录的<code class="highlighter-rouge">node_modules</code>子目录；其次，<code class="highlighter-rouge">node_modules/.bin</code>目录会生成一个符号链接<code class="highlighter-rouge">node_modules/.bin/eslint</code>，指向ESLint模块的可执行脚本。</p>

<p>然后，你就可以在<code class="highlighter-rouge">package.json</code>的<code class="highlighter-rouge">script</code>属性里面，不带路径的引用<code class="highlighter-rouge">eslint</code>这个脚本。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"Test Project"</span><span class="p">,</span>
  <span class="s2">"devDependencies"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"eslint"</span><span class="p">:</span> <span class="s2">"^1.10.3"</span>
  <span class="p">},</span>
  <span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"lint"</span><span class="p">:</span> <span class="s2">"eslint ."</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>等到运行<code class="highlighter-rouge">npm run lint</code>的时候，它会自动执行<code class="highlighter-rouge">./node_modules/.bin/eslint .</code>。</p>

<p>如果直接运行<code class="highlighter-rouge">npm run</code>不给出任何参数，就会列出<code class="highlighter-rouge">scripts</code>属性下所有命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm run
Available scripts <span class="k">in </span>the user-service package:
  lint
     jshint <span class="k">**</span>.js
  <span class="nb">test
    </span>mocha <span class="nb">test</span>/
</code></pre></div></div>

<p>下面是另一个<code class="highlighter-rouge">package.json</code>文件的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
  <span class="s2">"watch"</span><span class="p">:</span> <span class="s2">"watchify client/main.js -o public/app.js -v"</span><span class="p">,</span>
  <span class="s2">"build"</span><span class="p">:</span> <span class="s2">"browserify client/main.js -o public/app.js"</span><span class="p">,</span>
  <span class="s2">"start"</span><span class="p">:</span> <span class="s2">"npm run watch &amp; nodemon server.js"</span><span class="p">,</span>
  <span class="s2">"test"</span><span class="p">:</span> <span class="s2">"node test/all.js"</span>
<span class="p">},</span>
</code></pre></div></div>

<p>上面代码在<code class="highlighter-rouge">scripts</code>项，定义了四个别名，每个别名都有对应的脚本命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm run watch
<span class="nv">$ </span>npm run build
<span class="nv">$ </span>npm run start
<span class="nv">$ </span>npm run <span class="nb">test</span>
</code></pre></div></div>

<p>其中，<code class="highlighter-rouge">start</code>和<code class="highlighter-rouge">test</code>属于特殊命令，可以省略<code class="highlighter-rouge">run</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm start
<span class="nv">$ </span>npm <span class="nb">test</span>
</code></pre></div></div>

<p>如果希望一个操作的输出，是另一个操作的输入，可以借用Linux系统的管道命令，将两个操作连在一起。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"build-js"</span><span class="p">:</span> <span class="s2">"browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js"</span>
</code></pre></div></div>

<p>但是，更方便的写法是引用其他<code class="highlighter-rouge">npm run</code>命令。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"build"</span><span class="p">:</span> <span class="s2">"npm run build-js &amp;&amp; npm run build-css"</span>
</code></pre></div></div>

<p>上面的写法是先运行<code class="highlighter-rouge">npm run build-js</code>，然后再运行<code class="highlighter-rouge">npm run build-css</code>，两个命令中间用<code class="highlighter-rouge">&amp;&amp;</code>连接。如果希望两个命令同时平行执行，它们中间可以用<code class="highlighter-rouge">&amp;</code>连接。</p>

<p>下面是一个流操作的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"devDependencies"</span><span class="p">:</span> <span class="p">{</span>
  <span class="s2">"autoprefixer"</span><span class="p">:</span> <span class="s2">"latest"</span><span class="p">,</span>
  <span class="s2">"cssmin"</span><span class="p">:</span> <span class="s2">"latest"</span>
<span class="p">},</span>

<span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
  <span class="s2">"build:css"</span><span class="p">:</span> <span class="s2">"autoprefixer -b 'last 2 versions' &lt; assets/styles/main.css | cssmin &gt; dist/main.css"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>写在<code class="highlighter-rouge">scripts</code>属性中的命令，也可以在<code class="highlighter-rouge">node_modules/.bin</code>目录中直接写成bash脚本。下面是一个bash脚本。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#!/bin/bash
</span>
<span class="nx">cd</span> <span class="nx">site</span><span class="o">/</span><span class="nx">main</span>
<span class="nx">browserify</span> <span class="nx">browser</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="nx">js</span> <span class="o">|</span> <span class="nx">uglifyjs</span> <span class="o">-</span><span class="nx">mc</span> <span class="o">&gt;</span> <span class="kr">static</span><span class="o">/</span><span class="nx">bundle</span><span class="p">.</span><span class="nx">js</span>
</code></pre></div></div>

<p>假定上面的脚本文件名为build.sh，并且权限为可执行，就可以在scripts属性中引用该文件。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"build-js"</span><span class="p">:</span> <span class="s2">"bin/build.sh"</span>
</code></pre></div></div>

<h3 id="参数">参数</h3>

<p><code class="highlighter-rouge">npm run</code>命令还可以添加参数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
  <span class="s2">"test"</span><span class="p">:</span> <span class="s2">"mocha test/"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码指定<code class="highlighter-rouge">npm test</code>，实际运行<code class="highlighter-rouge">mocha test/</code>。如果要通过<code class="highlighter-rouge">npm test</code>命令，将参数传到mocha，则参数之前要加上两个连词线。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm run <span class="nb">test</span> <span class="nt">--</span> anothertest.js
<span class="c"># 等同于</span>
<span class="nv">$ </span>mocha <span class="nb">test</span>/ anothertest.js
</code></pre></div></div>

<p>上面命令表示，mocha要运行所有<code class="highlighter-rouge">test</code>子目录的测试脚本，以及另外一个测试脚本<code class="highlighter-rouge">anothertest.js</code>。</p>

<p><code class="highlighter-rouge">npm run</code>本身有一个参数<code class="highlighter-rouge">-s</code>，表示关闭npm本身的输出，只输出脚本产生的结果。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 输出npm命令头
<span class="nv">$ </span>npm run <span class="nb">test</span>

// 不输出npm命令头
<span class="nv">$ </span>npm run <span class="nt">-s</span> <span class="nb">test</span>
</code></pre></div></div>

<h3 id="scripts脚本命令最佳实践">scripts脚本命令最佳实践</h3>

<p><code class="highlighter-rouge">scripts</code>字段的脚本命令，有一些最佳实践，可以方便开发。首先，安装<code class="highlighter-rouge">npm-run-all</code>模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>npm-run-all <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>这个模块用于运行多个<code class="highlighter-rouge">scripts</code>脚本命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 继发执行</span>
<span class="nv">$ </span>npm-run-all build:html build:js
<span class="c"># 等同于</span>
<span class="nv">$ </span>npm run build:html <span class="o">&amp;&amp;</span> npm run build:js

<span class="c"># 并行执行</span>
<span class="nv">$ </span>npm-run-all <span class="nt">--parallel</span> watch:html watch:js
<span class="c"># 等同于</span>
<span class="nv">$ </span>npm run watch:html &amp; npm run watch:js

<span class="c"># 混合执行</span>
<span class="nv">$ </span>npm-run-all clean lint <span class="nt">--parallel</span> watch:html watch:js
<span class="c"># 等同于</span>
<span class="nv">$ </span>npm-run-all clean lint
<span class="nv">$ </span>npm-run-all <span class="nt">--parallel</span> watch:html watch:js

<span class="c"># 通配符</span>
<span class="nv">$ </span>npm-run-all <span class="nt">--parallel</span> watch:<span class="k">*</span>
</code></pre></div></div>

<p>（1）start脚本命令</p>

<p><code class="highlighter-rouge">start</code>脚本命令，用于启动应用程序。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"start"</span><span class="p">:</span> <span class="s2">"npm-run-all --parallel dev serve"</span>
</code></pre></div></div>

<p>上面命令并行执行<code class="highlighter-rouge">dev</code>脚本命令和<code class="highlighter-rouge">serve</code>脚本命令，等同于下面的形式。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm run dev &amp; npm run serve
</code></pre></div></div>

<p>如果start脚本没有配置，<code class="highlighter-rouge">npm start</code>命令默认执行下面的脚本，前提是模块的根目录存在一个server.js文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node server.js
</code></pre></div></div>

<p>（2）dev脚本命令</p>

<p><code class="highlighter-rouge">dev</code>脚本命令，规定开发阶段所要做的处理，比如构建网页资源。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"dev"</span><span class="p">:</span> <span class="s2">"npm-run-all dev:*"</span>
</code></pre></div></div>

<p>上面命令用于继发执行所有<code class="highlighter-rouge">dev</code>的子命令。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"predev:sass"</span><span class="p">:</span> <span class="s2">"node-sass --source-map src/css/hoodie.css.map --output-style nested src/sass/base.scss src/css/hoodie.css"</span>
</code></pre></div></div>

<p>上面命令将sass文件编译为css文件，并生成source map文件。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"dev:sass"</span><span class="p">:</span> <span class="s2">"node-sass --source-map src/css/hoodie.css.map --watch --output-style nested src/sass/base.scss src/css/hoodie.css"</span>
</code></pre></div></div>

<p>上面命令会监视sass文件的变动，只要有变动，就自动将其编译为css文件。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"dev:autoprefix"</span><span class="p">:</span> <span class="s2">"postcss --use autoprefixer --autoprefixer.browsers </span><span class="se">\"</span><span class="s2">&gt; 5%</span><span class="se">\"</span><span class="s2"> --output src/css/hoodie.css src/css/hoodie.css"</span>
</code></pre></div></div>

<p>上面命令为css文件加上浏览器前缀，限制条件是只考虑市场份额大于5%的浏览器。</p>

<p>（3）serve脚本命令</p>

<p><code class="highlighter-rouge">serve</code>脚本命令用于启动服务。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"serve"</span><span class="p">:</span> <span class="s2">"live-server dist/ --port=9090"</span>
</code></pre></div></div>

<p>上面命令启动服务，用的是<a href="http://npmjs.com/package/live-server">live-server</a>模块，将服务启动在9090端口，展示<code class="highlighter-rouge">dist</code>子目录。</p>

<p><code class="highlighter-rouge">live-server</code>模块有三个功能。</p>

<ul>
  <li>启动一个HTTP服务器，展示指定目录的<code class="highlighter-rouge">index.html</code>文件，通过该文件加载各种网络资源，这是<code class="highlighter-rouge">file://</code>协议做不到的。</li>
  <li>添加自动刷新功能。只要指定目录之中，文件有任何变化，它就会刷新页面。</li>
  <li><code class="highlighter-rouge">npm run serve</code>命令执行以后，自动打开浏览器。、</li>
</ul>

<p>以前，上面三个功能需要三个模块来完成：<code class="highlighter-rouge">http-server</code>、<code class="highlighter-rouge">live-reload</code>和<code class="highlighter-rouge">opener</code>，现在只要<code class="highlighter-rouge">live-server</code>一个模块就够了。</p>

<p>（4）test脚本命令</p>

<p><code class="highlighter-rouge">test</code>脚本命令用于执行测试。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"test"</span><span class="p">:</span> <span class="s2">"npm-run-all test:*"</span><span class="p">,</span>
<span class="s2">"test:lint"</span><span class="p">:</span> <span class="s2">"sass-lint --verbose --config .sass-lint.yml src/sass/*"</span>
</code></pre></div></div>

<p>上面命令规定，执行测试时，运行<code class="highlighter-rouge">lint</code>脚本，检查脚本之中的语法错误。</p>

<p>（5）prod脚本命令</p>

<p><code class="highlighter-rouge">prod</code>脚本命令，规定进入生产环境时需要做的处理。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"prod"</span><span class="p">:</span> <span class="s2">"npm-run-all prod:*"</span><span class="p">,</span>
<span class="s2">"prod:sass"</span><span class="p">:</span> <span class="s2">"node-sass --output-style compressed src/sass/base.scss src/css/prod/hoodie.min.css"</span><span class="p">,</span>
<span class="s2">"prod:autoprefix"</span><span class="p">:</span> <span class="s2">"postcss --use autoprefixer --autoprefixer.browsers "</span><span class="o">&gt;</span> <span class="mi">5</span><span class="o">%</span><span class="s2">" --output src/css/prod/hoodie.min.css src/css/prod/hoodie.min.css"</span>
</code></pre></div></div>

<p>上面命令将sass文件转为css文件，并加上浏览器前缀。</p>

<p>（6）help脚本命令</p>

<p><code class="highlighter-rouge">help</code>脚本命令用于展示帮助信息。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"help"</span><span class="p">:</span> <span class="s2">"markdown-chalk --input DEVELOPMENT.md"</span>
</code></pre></div></div>

<p>上面命令之中，<code class="highlighter-rouge">markdown-chalk</code>模块用于将指定的markdown文件，转为彩色文本显示在终端之中。</p>

<p>（7）docs脚本命令</p>

<p><code class="highlighter-rouge">docs</code>脚本命令用于生成文档。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"docs"</span><span class="p">:</span> <span class="s2">"kss-node --source src/sass --homepage ../../styleguide.md"</span>
</code></pre></div></div>

<p>上面命令使用<code class="highlighter-rouge">kss-node</code>模块，提供源码的注释生成markdown格式的文档。</p>

<h3 id="pre--和-post--脚本">pre- 和 post- 脚本</h3>

<p><code class="highlighter-rouge">npm run</code>为每条命令提供了<code class="highlighter-rouge">pre-</code>和<code class="highlighter-rouge">post-</code>两个钩子（hook）。以<code class="highlighter-rouge">npm run lint</code>为例，执行这条命令之前，npm会先查看有没有定义prelint和postlint两个钩子，如果有的话，就会先执行<code class="highlighter-rouge">npm run prelint</code>，然后执行<code class="highlighter-rouge">npm run lint</code>，最后执行<code class="highlighter-rouge">npm run postlint</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"myproject"</span><span class="p">,</span>
  <span class="s2">"devDependencies"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"eslint"</span><span class="p">:</span> <span class="s2">"latest"</span>
    <span class="s2">"karma"</span><span class="p">:</span> <span class="s2">"latest"</span>
  <span class="p">},</span>
  <span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"lint"</span><span class="p">:</span> <span class="s2">"eslint --cache --ext .js --ext .jsx src"</span><span class="p">,</span>
    <span class="s2">"test"</span><span class="p">:</span> <span class="s2">"karma start --log-leve=error karma.config.js --single-run=true"</span><span class="p">,</span>
    <span class="s2">"pretest"</span><span class="p">:</span> <span class="s2">"npm run lint"</span><span class="p">,</span>
    <span class="s2">"posttest"</span><span class="p">:</span> <span class="s2">"echo 'Finished running tests'"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码是一个<code class="highlighter-rouge">package.json</code>文件的例子。如果执行<code class="highlighter-rouge">npm test</code>，会按下面的顺序执行相应的命令。</p>

<ol>
  <li><code class="highlighter-rouge">pretest</code></li>
  <li><code class="highlighter-rouge">test</code></li>
  <li><code class="highlighter-rouge">posttest</code></li>
</ol>

<p>如果执行过程出错，就不会执行排在后面的脚本，即如果prelint脚本执行出错，就不会接着执行lint和postlint脚本。</p>

<p>下面是一个例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"test"</span><span class="p">:</span> <span class="s2">"karma start"</span><span class="p">,</span>
  <span class="s2">"test:lint"</span><span class="p">:</span> <span class="s2">"eslint . --ext .js --ext .jsx"</span><span class="p">,</span>
  <span class="s2">"pretest"</span><span class="p">:</span> <span class="s2">"npm run test:lint"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，在运行<code class="highlighter-rouge">npm run test</code>之前，会自动检查代码，即运行<code class="highlighter-rouge">npm run test:lint</code>命令。</p>

<p>下面是一些常见的<code class="highlighter-rouge">pre-</code>和<code class="highlighter-rouge">post-</code>脚本。</p>

<ul>
  <li><code class="highlighter-rouge">prepublish</code>：发布一个模块前执行。</li>
  <li><code class="highlighter-rouge">postpublish</code>：发布一个模块后执行。</li>
  <li><code class="highlighter-rouge">preinstall</code>：用户执行<code class="highlighter-rouge">npm install</code>命令时，先执行该脚本。</li>
  <li><code class="highlighter-rouge">postinstall</code>：用户执行<code class="highlighter-rouge">npm install</code>命令时，安装结束后执行该脚本，通常用于将下载的源码编译成用户需要的格式，比如有些模块需要在用户机器上跟本地的C++模块一起编译。</li>
  <li><code class="highlighter-rouge">preuninstall</code>：卸载一个模块前执行。</li>
  <li><code class="highlighter-rouge">postuninstall</code>：卸载一个模块后执行。</li>
  <li><code class="highlighter-rouge">preversion</code>：更改模块版本前执行。</li>
  <li><code class="highlighter-rouge">postversion</code>：更改模块版本后执行。</li>
  <li><code class="highlighter-rouge">pretest</code>：运行<code class="highlighter-rouge">npm test</code>命令前执行。</li>
  <li><code class="highlighter-rouge">posttest</code>：运行<code class="highlighter-rouge">npm test</code>命令后执行。</li>
  <li><code class="highlighter-rouge">prestop</code>：运行<code class="highlighter-rouge">npm stop</code>命令前执行。</li>
  <li><code class="highlighter-rouge">poststop</code>：运行<code class="highlighter-rouge">npm stop</code>命令后执行。</li>
  <li><code class="highlighter-rouge">prestart</code>：运行<code class="highlighter-rouge">npm start</code>命令前执行。</li>
  <li><code class="highlighter-rouge">poststart</code>：运行<code class="highlighter-rouge">npm start</code>命令后执行。</li>
  <li><code class="highlighter-rouge">prerestart</code>：运行<code class="highlighter-rouge">npm restart</code>命令前执行。</li>
  <li><code class="highlighter-rouge">postrestart</code>：运行<code class="highlighter-rouge">npm restart</code>命令后执行。</li>
</ul>

<p>对于最后一个<code class="highlighter-rouge">npm restart</code>命令，如果没有设置<code class="highlighter-rouge">restart</code>脚本，<code class="highlighter-rouge">prerestart</code>和<code class="highlighter-rouge">postrestart</code>会依次执行stop和start脚本。</p>

<p>另外，不能在<code class="highlighter-rouge">pre</code>脚本之前再加<code class="highlighter-rouge">pre</code>，即<code class="highlighter-rouge">prepretest</code>脚本不起作用。</p>

<p>注意，即使Npm可以自动运行<code class="highlighter-rouge">pre</code>和<code class="highlighter-rouge">post</code>脚本，也可以手动执行它们。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm run prepublish
</code></pre></div></div>

<p>下面是<code class="highlighter-rouge">post install</code>的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"postinstall"</span><span class="p">:</span> <span class="s2">"node lib/post_install.js"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的这个命令，主要用于处理从Git仓库拉下来的源码。比如，有些源码是用TypeScript写的，可能需要转换一下。</p>

<p>下面是<code class="highlighter-rouge">publish</code>钩子的一个例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"dist:modules"</span><span class="p">:</span> <span class="s2">"babel ./src --out-dir ./dist-modules"</span><span class="p">,</span>
  <span class="s2">"gh-pages"</span><span class="p">:</span> <span class="s2">"webpack"</span><span class="p">,</span>
  <span class="s2">"gh-pages:deploy"</span><span class="p">:</span> <span class="s2">"gh-pages -d gh-pages"</span><span class="p">,</span>
  <span class="s2">"prepublish"</span><span class="p">:</span> <span class="s2">"npm run dist:modules"</span><span class="p">,</span>
  <span class="s2">"postpublish"</span><span class="p">:</span> <span class="s2">"npm run gh-pages &amp;&amp; npm run gh-pages:deploy"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面命令在运行<code class="highlighter-rouge">npm run publish</code>时，会先执行Babel编译，然后调用Webpack构建，最后发到Github Pages上面。</p>

<p>以上都是npm相关操作的钩子，如果安装某些模块，还能支持Git相关的钩子。下面以<a href="https://github.com/typicode/husky">husky</a>模块为例。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>husky <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>安装以后，就能在<code class="highlighter-rouge">package.json</code>添加<code class="highlighter-rouge">precommit</code>、<code class="highlighter-rouge">prepush</code>等钩子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">"lint"</span><span class="p">:</span> <span class="s2">"eslint yourJsFiles.js"</span><span class="p">,</span>
        <span class="s2">"precommit"</span><span class="p">:</span> <span class="s2">"npm run test &amp;&amp; npm run lint"</span><span class="p">,</span>
        <span class="s2">"prepush"</span><span class="p">:</span> <span class="s2">"npm run test &amp;&amp; npm run lint"</span><span class="p">,</span>
        <span class="s2">"..."</span><span class="p">:</span> <span class="s2">"..."</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>类似作用的模块还有<code class="highlighter-rouge">pre-commit</code>、<code class="highlighter-rouge">precommit-hook</code>等。</p>

<h3 id="内部变量">内部变量</h3>

<p>scripts字段可以使用一些内部变量，主要是package.json的各种字段。</p>

<p>比如，package.json的内容是<code class="highlighter-rouge">{"name":"foo", "version":"1.2.5"}</code>，那么变量<code class="highlighter-rouge">npm_package_name</code>的值是foo，变量<code class="highlighter-rouge">npm_package_version</code>的值是1.2.5。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"scripts"</span><span class="p">:{</span>
    <span class="s2">"bundle"</span><span class="p">:</span> <span class="s2">"mkdir -p build/$npm_package_version/"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行<code class="highlighter-rouge">npm run bundle</code>以后，将会生成<code class="highlighter-rouge">build/1.2.5/</code>子目录。</p>

<p><code class="highlighter-rouge">config</code>字段也可以用于设置内部字段。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"fooproject"</span><span class="p">,</span>
  <span class="s2">"config"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"reporter"</span><span class="p">:</span> <span class="s2">"xunit"</span>
  <span class="p">},</span>
  <span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"test"</span><span class="p">:</span> <span class="s2">"mocha test/ --reporter $npm_package_config_reporter"</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，变量<code class="highlighter-rouge">npm_package_config_reporter</code>对应的就是reporter。</p>

<h3 id="通配符">通配符</h3>

<p>npm的通配符的规则如下。</p>

<ul>
  <li><code class="highlighter-rouge">*</code> 匹配0个或多个字符</li>
  <li><code class="highlighter-rouge">?</code> 匹配1个字符</li>
  <li><code class="highlighter-rouge">[...]</code> 匹配某个范围的字符。如果该范围的第一个字符是<code class="highlighter-rouge">!</code>或<code class="highlighter-rouge">^</code>，则匹配不在该范围的字符。</li>
  <li><code class="highlighter-rouge">!(pattern|pattern|pattern)</code> 匹配任何不符合给定的模式</li>
  <li><code class="highlighter-rouge">?(pattern|pattern|pattern)</code> 匹配0个或1个给定的模式</li>
  <li><code class="highlighter-rouge">+(pattern|pattern|pattern)</code> 匹配1个或多个给定的模式</li>
  <li><code class="highlighter-rouge">*(a|b|c)</code> 匹配0个或多个给定的模式</li>
  <li><code class="highlighter-rouge">@(pattern|pat*|pat?erN)</code> 只匹配给定模式之一</li>
  <li><code class="highlighter-rouge">**</code> 如果出现在路径部分，表示0个或多个子目录。</li>
</ul>

<h2 id="npm-link">npm link</h2>

<p>开发NPM模块的时候，有时我们会希望，边开发边试用，比如本地调试的时候，<code class="highlighter-rouge">require('myModule')</code>会自动加载本机开发中的模块。Node规定，使用一个模块时，需要将其安装到全局的或项目的<code class="highlighter-rouge">node_modules</code>目录之中。对于开发中的模块，解决方法就是在全局的<code class="highlighter-rouge">node_modules</code>目录之中，生成一个符号链接，指向模块的本地目录。</p>

<p><code class="highlighter-rouge">npm link</code>就能起到这个作用，会自动建立这个符号链接。</p>

<p>请设想这样一个场景，你开发了一个模块<code class="highlighter-rouge">myModule</code>，目录为<code class="highlighter-rouge">src/myModule</code>，你自己的项目<code class="highlighter-rouge">myProject</code>要用到这个模块，项目目录为<code class="highlighter-rouge">src/myProject</code>。首先，在模块目录（<code class="highlighter-rouge">src/myModule</code>）下运行<code class="highlighter-rouge">npm link</code>命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/myModule<span class="nv">$ </span>npm <span class="nb">link</span>
</code></pre></div></div>

<p>上面的命令会在NPM的全局模块目录内，生成一个符号链接文件，该文件的名字就是<code class="highlighter-rouge">package.json</code>文件中指定的模块名。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/path/to/global/node_modules/myModule -&gt; src/myModule
</code></pre></div></div>

<p>这个时候，已经可以全局调用<code class="highlighter-rouge">myModule</code>模块了。但是，如果我们要让这个模块安装在项目内，还要进行下面的步骤。</p>

<p>切换到项目目录，再次运行<code class="highlighter-rouge">npm link</code>命令，并指定模块名。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/myProject<span class="nv">$ </span>npm <span class="nb">link </span>myModule
</code></pre></div></div>

<p>上面命令等同于生成了本地模块的符号链接。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/myProject/node_modules/myModule -&gt; /path/to/global/node_modules/myModule
</code></pre></div></div>

<p>然后，就可以在你的项目中，加载该模块了。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'myModule'</span><span class="p">);</span>
</code></pre></div></div>

<p>这样一来，<code class="highlighter-rouge">myModule</code>的任何变化，都可以直接反映在<code class="highlighter-rouge">myProject</code>项目之中。但是，这样也出现了风险，任何在<code class="highlighter-rouge">myProject</code>目录中对<code class="highlighter-rouge">myModule</code>的修改，都会反映到模块的源码中。</p>

<p>如果你的项目不再需要该模块，可以在项目目录内使用<code class="highlighter-rouge">npm unlink</code>命令，删除符号链接。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/myProject<span class="nv">$ </span>npm <span class="nb">unlink </span>myModule
</code></pre></div></div>

<h2 id="npm-bin">npm bin</h2>

<p><code class="highlighter-rouge">npm bin</code>命令显示相对于当前目录的，Node模块的可执行脚本所在的目录（即<code class="highlighter-rouge">.bin</code>目录）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 项目根目录下执行</span>
<span class="nv">$ </span>npm bin
./node_modules/.bin
</code></pre></div></div>

<h2 id="npm-adduser">npm adduser</h2>

<p><code class="highlighter-rouge">npm adduser</code>用于在npmjs.com注册一个用户。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm adduser
Username: YOUR_USER_NAME
Password: YOUR_PASSWORD
Email: YOUR_EMAIL@domain.com
</code></pre></div></div>

<h2 id="npm-publish">npm publish</h2>

<p><code class="highlighter-rouge">npm publish</code>用于将当前模块发布到<code class="highlighter-rouge">npmjs.com</code>。执行之前，需要向<code class="highlighter-rouge">npmjs.com</code>申请用户名。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm adduser
</code></pre></div></div>

<p>如果已经注册过，就使用下面的命令登录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm login
</code></pre></div></div>

<p>登录以后，就可以使用<code class="highlighter-rouge">npm publish</code>命令发布。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm publish
</code></pre></div></div>

<p>如果当前模块是一个beta版，比如<code class="highlighter-rouge">1.3.1-beta.3</code>，那么发布的时候需要使用<code class="highlighter-rouge">tag</code>参数，将其发布到指定标签，默认的发布标签是<code class="highlighter-rouge">latest</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm publish <span class="nt">--tag</span> beta
</code></pre></div></div>

<p>如果发布私有模块，模块初始化的时候，需要加上<code class="highlighter-rouge">scope</code>参数。只有npm的付费用户才能发布私有模块。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm init <span class="nt">--scope</span><span class="o">=</span>&lt;yourscope&gt;
</code></pre></div></div>

<p>如果你的模块是用ES6写的，那么发布的时候，最好转成ES5。首先，需要安装Babel。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span> <span class="nx">npm</span> <span class="nx">install</span> <span class="o">--</span><span class="nx">save</span><span class="o">-</span><span class="nx">dev</span> <span class="nx">babel</span><span class="o">-</span><span class="nx">cli</span><span class="p">@</span><span class="nd">6</span> <span class="nx">babel</span><span class="o">-</span><span class="nx">preset</span><span class="o">-</span><span class="nx">es2015</span><span class="p">@</span><span class="nd">6</span>
</code></pre></div></div>

<p>然后，在<code class="highlighter-rouge">package.json</code>里面写入<code class="highlighter-rouge">build</code>脚本。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
  <span class="s2">"build"</span><span class="p">:</span> <span class="s2">"babel source --presets babel-preset-es2015 --out-dir distribution"</span><span class="p">,</span>
  <span class="s2">"prepublish"</span><span class="p">:</span> <span class="s2">"npm run build"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行上面的脚本，会将<code class="highlighter-rouge">source</code>目录里面的ES6源码文件，转为<code class="highlighter-rouge">distribution</code>目录里面的ES5源码文件。然后，在项目根目录下面创建两个文件<code class="highlighter-rouge">.npmignore</code>和<code class="highlighter-rouge">.gitignore</code>，分别写入以下内容。</p>

<pre><code class="language-javascrip">// .npmignore
source

// .gitignore
node_modules
distribution
</code></pre>

<h2 id="npm-deprecate">npm deprecate</h2>

<p>如果想废弃某个版本的模块，可以使用<code class="highlighter-rouge">npm deprecate</code>命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm deprecate my-thing@<span class="s2">"&lt; 0.2.3"</span> <span class="s2">"critical bug fixed in v0.2.3"</span>
</code></pre></div></div>

<p>运行上面的命令以后，小于<code class="highlighter-rouge">0.2.3</code>版本的模块的<code class="highlighter-rouge">package.json</code>都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示。</p>

<h2 id="npm-owner">npm owner</h2>

<p>模块的维护者可以发布新版本。<code class="highlighter-rouge">npm owner</code>命令用于管理模块的维护者。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 列出指定模块的维护者</span>
<span class="nv">$ </span>npm owner <span class="nb">ls</span> &lt;package name&gt;

<span class="c"># 新增维护者</span>
<span class="nv">$ </span>npm owner add &lt;user&gt; &lt;package name&gt;

<span class="c"># 删除维护者</span>
<span class="nv">$ </span>npm owner <span class="nb">rm</span> &lt;user&gt; &lt;package name&gt;
</code></pre></div></div>

<h2 id="其他命令">其他命令</h2>

<h3 id="npm-homenpm-repo">npm home，npm repo</h3>

<p><code class="highlighter-rouge">npm home</code>命令可以打开一个模块的主页，<code class="highlighter-rouge">npm repo</code>命令则是打开一个模块的代码仓库。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm home <span class="nv">$package</span>
<span class="nv">$ </span>npm repo <span class="nv">$package</span>
</code></pre></div></div>

<p>这两个命令不需要模块先安装。</p>

<h3 id="npm-outdated">npm outdated</h3>

<p><code class="highlighter-rouge">npm outdated</code>命令检查当前项目所依赖的模块，是否已经有新版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm outdated
</code></pre></div></div>

<p>它会输出当前版本（current version）、应当安装的版本（wanted version）和最新发布的版本（latest version）。</p>

<h3 id="npm-prune">npm prune</h3>

<p><code class="highlighter-rouge">npm prune</code>检查当前项目的<code class="highlighter-rouge">node_modules</code>目录中，是否有<code class="highlighter-rouge">package.json</code>里面没有提到的模块，然后将所有这些模块输出在命令行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm prune
</code></pre></div></div>

<h3 id="npm-shrinkwrap">npm shrinkwrap</h3>

<p><code class="highlighter-rouge">npm shrinkwrap</code>的作用是锁定当前项目的依赖模块的版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm shrinkwrap
</code></pre></div></div>

<p>运行该命令后，会在当前项目的根目录下生成一个<code class="highlighter-rouge">npm-shrinkwrap.json</code>文件，内容是<code class="highlighter-rouge">node_modules</code>目录下所有已经安装的模块，以及它们的精确版本。</p>

<p>下次运行<code class="highlighter-rouge">npm install</code>命令时，<code class="highlighter-rouge">npm</code>发现当前目录下有<code class="highlighter-rouge">npm-shrinkwrap.json</code>文件，就会只安装里面提到的模块，且版本也会保持一致。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>James Halliday, <a href="http://substack.net/task_automation_with_npm_run">task automation with npm run</a>: npm run命令（package.json文件的script属性）的用法</li>
  <li>Keith Cirkel, <a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/">How to Use npm as a Build Tool</a></li>
  <li>justjs, <a href="http://justjs.com/posts/npm-link-developing-your-own-npm-modules-without-tears">npm link: developing your own npm modules without tears</a></li>
  <li>hoodie-css, <a href="https://github.com/hoodiehq/hoodie-css/blob/feature/build-automation/DEVELOPMENT.md">Development Environment Help</a></li>
  <li>Stephan Bönnemann, <a href="https://medium.com/greenkeeper-blog/one-simple-trick-for-javascript-package-maintainers-to-avoid-breaking-their-user-s-software-and-to-6edf06dc5617#.5omqgsg45">How to make use of npm’s package distribution tags to create release channels</a></li>
  <li>Alex Booker, <a href="https://booker.codes/how-to-build-and-publish-es6-npm-modules-today-with-babel/">How to Build and Publish ES6 npm Modules Today, with Babel</a></li>
</ul>


</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="/introduction/license.html">版权声明</a> | last modified on 2014-10-24 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


