<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>Node.js 概述 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="/js/jquery.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="/#introduction">导论</a></li>
			
			<li><a href="/#grammar">语法</a></li>
			
			<li><a href="/#stdlib">标准库</a></li>
			
			<li><a href="/#oop">面向对象编程</a></li>
			
			<li><a href="/#advanced">语法专题</a></li>
			
			<li><a href="/#dom">DOM模型</a></li>
			
			<li><a href="/#bom">浏览器环境</a></li>
			
			<li><a href="/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> 草稿二：Node.js </a><ul class="dropdown">













<li><a href="/nodejs/assert.html">assert 模块</a></li>













<li class="active"><a href="#">Node.js 概述</a></li>













<li><a href="/nodejs/buffer.html">Buffer对象</a></li>





<li><a href="/nodejs/child-process.html">Child Process模块</a></li>





<li><a href="/nodejs/cluster.html">Cluster模块</a></li>

























<li><a href="/nodejs/develop.html">Node应用程序开发</a></li>





<li><a href="/nodejs/dns.html">dns 模块</a></li>





















<li><a href="/nodejs/events.html">Events模块</a></li>







<li><a href="/nodejs/express.html">Express框架</a></li>









<li><a href="/nodejs/fs.html">fs 模块</a></li>



















<li><a href="/nodejs/http.html">Http模块</a></li>



















<li><a href="/nodejs/koa.html">Koa 框架</a></li>

















<li><a href="/nodejs/module.html">CommonJS规范</a></li>





<li><a href="/nodejs/mongodb.html">MongoDB的应用</a></li>







<li><a href="/nodejs/net.html">Net模块和DNS模块</a></li>









<li><a href="/nodejs/npm.html">npm模块管理器</a></li>

















<li><a href="/nodejs/os.html">os模块</a></li>





<li><a href="/nodejs/packagejson.html">package.json文件</a></li>







<li><a href="/nodejs/path.html">Path模块</a></li>















<li><a href="/nodejs/process.html">process对象</a></li>











<li><a href="/nodejs/querystring.html">querystring 模块</a></li>





















<li><a href="/nodejs/stream.html">Stream接口</a></li>



























<li><a href="/nodejs/url.html">url 模块</a></li>





















</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> Node.js 概述</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> Node.js 概述 </h1>

<aside class="right"><p>来自<a href="/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<h2 id="简介">简介</h2>

<p>Node是JavaScript语言的服务器运行环境。</p>

<p>所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机；其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库。</p>

<p>Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。</p>

<h3 id="安装与更新">安装与更新</h3>

<p>访问官方网站<a href="http://nodejs.org">nodejs.org</a>或者<a href="https://github.com/nodesource/distributions">github.com/nodesource/distributions</a>，查看Node的最新版本和安装方法。</p>

<p>官方网站提供编译好的二进制包，可以把它们解压到<code class="highlighter-rouge">/usr/local</code>目录下面。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">tar</span> <span class="nt">-xf</span> node-someversion.tgz
</code></pre></div></div>

<p>然后，建立符号链接，把它们加到$PATH变量里面的路径。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-s</span> /usr/local/node/bin/node /usr/local/bin/node
<span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-s</span> /usr/local/node/bin/npm /usr/local/bin/npm
</code></pre></div></div>

<p>下面是Ubuntu和Debian下面安装Deb软件包的安装方法。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-sL</span> https://deb.nodesource.com/setup_4.x | <span class="nb">sudo</span> <span class="nt">-E</span> bash -
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> nodejs

<span class="nv">$ </span>apt-get <span class="nb">install </span>nodejs
</code></pre></div></div>

<p>安装完成以后，运行下面的命令，查看是否能正常运行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node <span class="nt">--version</span>
<span class="c"># 或者</span>
<span class="nv">$ </span>node <span class="nt">-v</span>
</code></pre></div></div>

<p>更新node.js版本，可以通过node.js的<code class="highlighter-rouge">n</code>模块完成。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>npm <span class="nb">install </span>n <span class="nt">-g</span>
<span class="nv">$ </span><span class="nb">sudo </span>n stable
</code></pre></div></div>

<p>上面代码通过<code class="highlighter-rouge">n</code>模块，将node.js更新为最新发布的稳定版。</p>

<p><code class="highlighter-rouge">n</code>模块也可以指定安装特定版本的node。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>n 0.10.21
</code></pre></div></div>

<h3 id="版本管理工具nvm">版本管理工具nvm</h3>

<p>如果想在同一台机器，同时安装多个版本的node.js，就需要用到版本管理工具nvm。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/creationix/nvm.git ~/.nvm
<span class="nv">$ </span><span class="nb">source</span> ~/.nvm/nvm.sh
</code></pre></div></div>

<p>安装以后，nvm的执行脚本，每次使用前都要激活，建议将其加入~/.bashrc文件（假定使用Bash）。激活后，就可以安装指定版本的Node。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装最新版本</span>
<span class="nv">$ </span>nvm <span class="nb">install </span>node

<span class="c"># 安装指定版本</span>
<span class="nv">$ </span>nvm <span class="nb">install </span>0.12.1

<span class="c"># 使用已安装的最新版本</span>
<span class="nv">$ </span>nvm use node

<span class="c"># 使用指定版本的node</span>
<span class="nv">$ </span>nvm use 0.12
</code></pre></div></div>

<p>nvm也允许进入指定版本的REPL环境。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nvm run 0.12
</code></pre></div></div>

<p>如果在项目根目录下新建一个.nvmrc文件，将版本号写入其中，就只输入<code class="highlighter-rouge">nvm use</code>命令即可，不再需要附加版本号。</p>

<p>下面是其他经常用到的命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看本地安装的所有版本</span>
<span class="nv">$ </span>nvm <span class="nb">ls</span>

<span class="c"># 查看服务器上所有可供安装的版本。</span>
<span class="nv">$ </span>nvm ls-remote

<span class="c"># 退出已经激活的nvm，使用deactivate命令。</span>
<span class="nv">$ </span>nvm deactivate
</code></pre></div></div>

<h3 id="基本用法">基本用法</h3>

<p>安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本。</p>

<p>当前目录的<code class="highlighter-rouge">demo.js</code>脚本文件，可以这样执行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node demo
<span class="c"># 或者</span>
<span class="nv">$ </span>node demo.js
</code></pre></div></div>

<p>使用<code class="highlighter-rouge">-e</code>参数，可以执行代码字符串。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node <span class="nt">-e</span> <span class="s1">'console.log("Hello World")'</span>
Hello World
</code></pre></div></div>

<h3 id="repl环境">REPL环境</h3>

<p>在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，”读取-求值-输出”循环），可以直接运行各种JavaScript命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node
<span class="o">&gt;</span> 1+1
2
<span class="o">&gt;</span>
</code></pre></div></div>

<p>如果使用参数 –use_strict，则REPL将在严格模式下运行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node <span class="nt">--use_strict</span>
</code></pre></div></div>

<p>REPL是Node.js与用户互动的shell，各种基本的shell功能都可以在里面使用，比如使用上下方向键遍历曾经使用过的命令。</p>

<p>特殊变量下划线（_）表示上一个命令的返回结果。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> 1 + 1
2
<span class="o">&gt;</span> _ + 1
3
</code></pre></div></div>

<p>在REPL中，如果运行一个表达式，会直接在命令行返回结果。如果运行一条语句，就不会有任何输出，因为语句没有返回值。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">&gt;</span> x <span class="o">=</span> 1
1
<span class="o">&gt;</span> var x <span class="o">=</span> 1</code></pre></figure>

<p>上面代码的第二条命令，没有显示任何结果。因为这是一条语句，不是表达式，所以没有返回值。</p>

<h3 id="异步操作">异步操作</h3>

<p>Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous opertion），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。</p>

<p>由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">isTrue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">"Value was true."</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Value is not true!"</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>上面代码就把进一步的处理，交给回调函数callback。</p>

<p>Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>上面代码中，callback的第一个参数是Error对象，第二个参数才是真正的数据参数。这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
  <span class="nx">db</span><span class="p">.</span><span class="nx">User</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">userId</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
<span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">‘</span><span class="nx">Oh</span> <span class="nx">no</span><span class="o">!</span><span class="err">’</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，db.User.get方法是一个异步操作，等到抛出错误时，可能它所在的try…catch代码块早就运行结束了，这会导致错误无法被捕捉。所以，Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。</p>

<p>如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 除了放过No Permission错误意外，其他错误传给下一个回调函数</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">err</span><span class="p">.</span><span class="nx">noPermission</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="全局对象和全局变量">全局对象和全局变量</h3>

<p>Node提供以下几个全局对象，它们是所有模块都可以调用的。</p>

<ul>
  <li>
    <p><strong>global</strong>：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如<code class="highlighter-rouge">var x = 1</code>等同于设置<code class="highlighter-rouge">window.x = 1</code>，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明<code class="highlighter-rouge">var x = 1</code>，该变量不是<code class="highlighter-rouge">global</code>对象的属性，<code class="highlighter-rouge">global.x</code>等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。</p>
  </li>
  <li>
    <p><strong>process</strong>：该对象表示Node所处的当前进程，允许开发者与该进程互动。</p>
  </li>
  <li>
    <p><strong>console</strong>：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。</p>
  </li>
</ul>

<p>Node还提供一些全局函数。</p>

<ul>
  <li><strong>setTimeout()</strong>：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>
  <li><strong>clearTimeout()</strong>：用于终止一个setTimeout方法新建的定时器。</li>
  <li><strong>setInterval()</strong>：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>
  <li><strong>clearInterval()</strong>：终止一个用setInterval方法新建的定时器。</li>
  <li><strong>require()</strong>：用于加载模块。</li>
  <li><strong>Buffer()</strong>：用于操作二进制数据。</li>
</ul>

<p>Node提供两个全局变量，都以两个下划线开头。</p>

<ul>
  <li><code class="highlighter-rouge">__filename</code>：指向当前运行的脚本文件名。</li>
  <li><code class="highlighter-rouge">__dirname</code>：指向当前运行的脚本所在的目录。</li>
</ul>

<p>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>

<h2 id="模块化结构">模块化结构</h2>

<h3 id="概述">概述</h3>

<p>Node.js采用模块化结构，按照<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS规范</a>定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。</p>

<p>require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">circle</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./circle.js'</span><span class="p">);</span>
<span class="c1">// 或者</span>
<span class="kd">var</span> <span class="nx">circle</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./circle'</span><span class="p">);</span></code></pre></figure>

<p>require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span></code></pre></figure>

<p>有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="s2">"name"</span> <span class="p">:</span> <span class="s2">"bar"</span><span class="p">,</span>
  <span class="s2">"main"</span> <span class="p">:</span> <span class="s2">"./lib/bar.js"</span>
<span class="p">}</span></code></pre></figure>

<p>上面代码中，模块的启动文件为lib子目录下的bar.js。当使用<code class="highlighter-rouge">require('bar')</code>命令加载该模块时，实际上加载的是<code class="highlighter-rouge">./node_modules/bar/lib/bar.js</code>文件。下面写法会起到同样效果。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'bar/lib/bar.js'</span><span class="p">)</span>

</code></pre></div></div>

<p>如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。</p>

<p>模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。</p>

<h3 id="核心模块">核心模块</h3>

<p>如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。</p>

<ul>
  <li><strong>http</strong>：提供HTTP服务器功能。</li>
  <li><strong>url</strong>：解析URL。</li>
  <li><strong>fs</strong>：与文件系统交互。</li>
  <li><strong>querystring</strong>：解析URL的查询字符串。</li>
  <li><strong>child_process</strong>：新建子进程。</li>
  <li><strong>util</strong>：提供一系列实用小工具。</li>
  <li><strong>path</strong>：处理文件路径。</li>
  <li><strong>crypto</strong>：提供加密和解密功能，基本上是对OpenSSL的包装。</li>
</ul>

<p>上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。</p>

<p>核心模块总是最优先加载的。如果你自己写了一个HTTP模块，<code class="highlighter-rouge">require('http')</code>加载的还是核心模块。</p>

<h3 id="自定义模块">自定义模块</h3>

<p>Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。</p>

<p>下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// foo.js</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。</p>

<p>这个模块的使用方法如下。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// index.js</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./foo'</span><span class="p">);</span>

<span class="nx">m</span><span class="p">(</span><span class="s2">"这是自定义模块"</span><span class="p">);</span></code></pre></figure>

<p>上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>node index
这是自定义模块</code></pre></figure>

<p>module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// foo.js</span>

<span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">p</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">out</span><span class="p">.</span><span class="nx">print</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">out</span><span class="p">;</span></code></pre></figure>

<p>上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// index.js</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./foo'</span><span class="p">);</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="s2">"这是自定义模块"</span><span class="p">);</span></code></pre></figure>

<p>上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。</p>

<h2 id="异常处理">异常处理</h2>

<p>Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。</p>

<p>一般来说，Node有三种方法，传播一个错误。</p>

<ul>
  <li>使用throw语句抛出一个错误对象，即抛出异常。</li>
  <li>将错误对象传递给回调函数，由回调函数负责发出错误。</li>
  <li>通过EventEmitter接口，发出一个error事件。</li>
</ul>

<h3 id="trycatch结构">try…catch结构</h3>

<p>最常用的捕获异常的方式，就是使用try…catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"error"</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//can not catch it</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"error"</span><span class="p">);</span>
  <span class="p">},</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//can not catch it</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码分别用process.nextTick和setTimeout方法，在下一轮事件循环抛出两个异常，代表异步操作抛出的错误。它们都无法被catch代码块捕获，因为catch代码块所在的那部分已经运行结束了。</p>

<p>一种解决方法是将错误捕获代码，也放到异步执行。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="k">async</span><span class="p">(</span><span class="nx">cb</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"woops!"</span><span class="p">);</span>
      <span class="k">else</span>
        <span class="nx">cb</span><span class="p">(</span><span class="s2">"done"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">err</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="mi">2000</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">async</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"received:"</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Error: async threw an exception:"</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// Error: async threw an exception: Error: woops!</span>
</code></pre></div></div>

<p>上面代码中，async函数异步抛出的错误，可以同样部署在异步的catch代码块捕获。</p>

<p>这两种处理方法都不太理想。一般来说，Node只在很少场合才用try/catch语句，比如使用<code class="highlighter-rouge">JSON.parse</code>解析JSON文本。</p>

<h3 id="回调函数">回调函数</h3>

<p>Node采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">'/foo.txt'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码表示，读取文件<code class="highlighter-rouge">foo.txt</code>是一个异步操作，它的回调函数有两个参数，第一个是错误对象，第二个是读取到的文件数据。如果第一个参数不是null，就意味着发生错误，后面代码也就不再执行了。</p>

<p>下面是一个完整的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">async2</span><span class="p">(</span><span class="nx">continuation</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"woops!"</span><span class="p">);</span>
      <span class="k">else</span>
        <span class="nx">continuation</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span> <span class="c1">// pass 'null' for error</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">continuation</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">async2</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Error: (cps) failed:"</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"(cps) received:"</span><span class="p">,</span> <span class="nx">res</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// Error: (cps) failed: woops!</span>
</code></pre></div></div>

<p>上面代码中，async2函数的回调函数的第一个参数就是一个错误对象，这是为了处理异步操作抛出的错误。</p>

<h3 id="eventemitter接口的error事件">EventEmitter接口的error事件</h3>

<p>发生错误的时候，也可以用EventEmitter接口抛出error事件。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'events'</span><span class="p">).</span><span class="nx">EventEmitter</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">emitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="p">();</span>

<span class="nx">emitter</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'something bad happened'</span><span class="p">));</span>
</code></pre></div></div>

<p>使用上面的代码必须小心，因为如果没有对error事件部署监听函数，会导致整个应用程序崩溃。所以，一般总是必须同时部署下面的代码。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'出错：'</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="uncaughtexception事件">uncaughtException事件</h3>

<p>当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'tracer'</span><span class="p">).</span><span class="nx">console</span><span class="p">();</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'uncaughtException'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'Error caught in uncaughtException event:'</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"error"</span><span class="p">);</span>
  <span class="p">},</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//can not catch it</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'uncaughtException'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">logger</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="unhandledrejection事件">unhandledRejection事件</h3>

<p>iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Broken."</span><span class="p">));</span>
<span class="p">});</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div></div>

<p>上面代码中，promise的状态变为rejected，并且抛出一个错误。但是，不会有任何反应，因为没有设置任何处理函数。</p>

<p>只要监听unhandledRejection事件，就能解决这个问题。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unhandledRejection'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">stack</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div></div>

<p>需要注意的是，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是产生错误的promise对象。这可以提供很多有用的信息。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Broken."</span><span class="p">))</span>
  <span class="p">})</span>

  <span class="nx">promise</span><span class="p">.</span><span class="nx">info</span> <span class="o">=</span> <span class="p">{</span><span class="na">url</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">url</span><span class="p">}</span>
<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">)</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unhandledRejection'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">info</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Error in URL'</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">url</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>上面代码会在出错时，输出用户请求的网址。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Error</span> <span class="k">in</span> <span class="nx">URL</span> <span class="o">/</span><span class="nx">testurl</span>
<span class="nb">Error</span><span class="p">:</span> <span class="nx">Broken</span><span class="p">.</span>
  <span class="nx">at</span> <span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">mikeal</span><span class="o">/</span><span class="nx">tmp</span><span class="o">/</span><span class="nx">test</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">14</span>
  <span class="nx">at</span> <span class="nx">Server</span><span class="p">.</span><span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span> <span class="p">(</span><span class="sr">/Users/mi</span><span class="nx">keal</span><span class="o">/</span><span class="nx">tmp</span><span class="o">/</span><span class="nx">test</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">17</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">emitTwo</span> <span class="p">(</span><span class="nx">events</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">87</span><span class="p">:</span><span class="mi">13</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">Server</span><span class="p">.</span><span class="nx">emit</span> <span class="p">(</span><span class="nx">events</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">169</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">HTTPParser</span><span class="p">.</span><span class="nx">parserOnIncoming</span> <span class="p">[</span><span class="k">as</span> <span class="nx">onIncoming</span><span class="p">]</span> <span class="p">(</span><span class="nx">_http_server</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">471</span><span class="p">:</span><span class="mi">12</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">HTTPParser</span><span class="p">.</span><span class="nx">parserOnHeadersComplete</span> <span class="p">(</span><span class="nx">_http_common</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">88</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">Socket</span><span class="p">.</span><span class="nx">socketOnData</span> <span class="p">(</span><span class="nx">_http_server</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">322</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">emitOne</span> <span class="p">(</span><span class="nx">events</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">77</span><span class="p">:</span><span class="mi">13</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">Socket</span><span class="p">.</span><span class="nx">emit</span> <span class="p">(</span><span class="nx">events</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">166</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>
  <span class="nx">at</span> <span class="nx">readableAddChunk</span> <span class="p">(</span><span class="nx">_stream_readable</span><span class="p">.</span><span class="nx">js</span><span class="p">:</span><span class="mi">145</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="命令行脚本">命令行脚本</h2>

<p>node脚本可以作为命令行脚本使用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node foo.js
</code></pre></div></div>

<p>上面代码执行了foo.js脚本文件。</p>

<p>foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env node</span>
</code></pre></div></div>

<p>调用前，需更改文件的执行权限。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">chmod </span>u+x foo.js
<span class="nv">$ </span>./foo.js arg1 arg2 ...
</code></pre></div></div>

<p>作为命令行脚本时，<code class="highlighter-rouge">console.log</code>用于输出内容到标准输出，<code class="highlighter-rouge">process.stdin</code>用于读取标准输入，<code class="highlighter-rouge">child_process.exec()</code>用于执行一个shell命令。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>Cody Lindley, <a href="http://tech.pro/tutorial/1190/package-managers-an-introductory-guide-for-the-uninitiated-front-end-developer">Package Managers: An Introductory Guide For The Uninitiated Front-End Developer</a></li>
  <li>Stack Overflow, <a href="http://stackoverflow.com/questions/1884724/what-is-node-js">What is Node.js?</a></li>
  <li>Andrew Burgess, <a href="http://dev.tutsplus.com/tutorials/using-nodes-event-module--net-35941">Using Node’s Event Module</a></li>
  <li>James Halliday, <a href="http://substack.net/task_automation_with_npm_run">task automation with npm run</a>- Romain Prieto, <a href="http://www.asyncdev.net/2013/12/working-on-related-node-modules-locally/">Working on related Node.js modules locally</a></li>
  <li>Alon Salant, <a href="http://bites.goodeggs.com/posts/export-this/">Export This: Interface Design Patterns for Node.js Modules</a></li>
  <li>Node.js Manual &amp; Documentation, <a href="http://nodejs.org/api/modules.html">Modules</a></li>
  <li>Brent Ertz, <a href="http://quickleft.com/blog/creating-and-publishing-a-node-js-module">Creating and publishing a node.js module</a></li>
  <li>Fred K Schott, <a href="http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/">“npm install –save” No Longer Using Tildes</a></li>
  <li>Satans17, <a href="http://satans17.github.io/2014/05/04/node%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E7%A0%94%E7%A9%B6%E5%BF%83%E5%BE%97/">Node稳定性的研究心得</a></li>
  <li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/12/nodejs-shell-scripting.html">Write your shell scripts in JavaScript, via Node.js</a></li>
</ul>


</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="/introduction/license.html">版权声明</a> | last modified on 2013-12-04 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


