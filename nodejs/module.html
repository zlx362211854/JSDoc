<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>CommonJS规范 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="/js/jquery.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="/#introduction">导论</a></li>
			
			<li><a href="/#grammar">语法</a></li>
			
			<li><a href="/#stdlib">标准库</a></li>
			
			<li><a href="/#oop">面向对象编程</a></li>
			
			<li><a href="/#advanced">语法专题</a></li>
			
			<li><a href="/#dom">DOM模型</a></li>
			
			<li><a href="/#bom">浏览器环境</a></li>
			
			<li><a href="/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> 草稿二：Node.js </a><ul class="dropdown">













<li><a href="/nodejs/assert.html">assert 模块</a></li>













<li><a href="/nodejs/basic.html">Node.js 概述</a></li>













<li><a href="/nodejs/buffer.html">Buffer对象</a></li>





<li><a href="/nodejs/child-process.html">Child Process模块</a></li>





<li><a href="/nodejs/cluster.html">Cluster模块</a></li>

























<li><a href="/nodejs/develop.html">Node应用程序开发</a></li>





<li><a href="/nodejs/dns.html">dns 模块</a></li>





















<li><a href="/nodejs/events.html">Events模块</a></li>







<li><a href="/nodejs/express.html">Express框架</a></li>









<li><a href="/nodejs/fs.html">fs 模块</a></li>



















<li><a href="/nodejs/http.html">Http模块</a></li>



















<li><a href="/nodejs/koa.html">Koa 框架</a></li>

















<li class="active"><a href="#">CommonJS规范</a></li>





<li><a href="/nodejs/mongodb.html">MongoDB的应用</a></li>







<li><a href="/nodejs/net.html">Net模块和DNS模块</a></li>









<li><a href="/nodejs/npm.html">npm模块管理器</a></li>

















<li><a href="/nodejs/os.html">os模块</a></li>





<li><a href="/nodejs/packagejson.html">package.json文件</a></li>







<li><a href="/nodejs/path.html">Path模块</a></li>















<li><a href="/nodejs/process.html">process对象</a></li>











<li><a href="/nodejs/querystring.html">querystring 模块</a></li>





















<li><a href="/nodejs/stream.html">Stream接口</a></li>



























<li><a href="/nodejs/url.html">url 模块</a></li>





















</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> CommonJS规范</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> CommonJS规范 </h1>

<aside class="right"><p>来自<a href="/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<h2 id="概述">概述</h2>

<p>Node 应用由模块组成，采用 CommonJS 模块规范。</p>

<p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example.js</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">addX</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">+</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上面代码中，变量<code class="highlighter-rouge">x</code>和函数<code class="highlighter-rouge">addX</code>，是当前文件<code class="highlighter-rouge">example.js</code>私有的，其他文件不可见。</p>

<p>如果想在多个文件分享变量，必须定义为<code class="highlighter-rouge">global</code>对象的属性。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">global</span><span class="p">.</span><span class="nx">warning</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码的<code class="highlighter-rouge">warning</code>变量，可以被所有文件读取。当然，这样写法是不推荐的。</p>

<p>CommonJS规范规定，每个模块内部，<code class="highlighter-rouge">module</code>变量代表当前模块。这个变量是一个对象，它的<code class="highlighter-rouge">exports</code>属性（即<code class="highlighter-rouge">module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code class="highlighter-rouge">module.exports</code>属性。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">addX</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">+</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">addX</span> <span class="o">=</span> <span class="nx">addX</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码通过<code class="highlighter-rouge">module.exports</code>输出变量<code class="highlighter-rouge">x</code>和函数<code class="highlighter-rouge">addX</code>。</p>

<p><code class="highlighter-rouge">require</code>方法用于加载模块。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">example</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./example.js'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 5</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">example</span><span class="p">.</span><span class="nx">addX</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 6</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">require</code>方法的详细解释参见《Require命令》一节。</p>

<p>CommonJS模块的特点如下。</p>

<ul>
  <li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
  <li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
  <li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>

<h2 id="module对象">module对象</h2>

<p>Node内部提供一个<code class="highlighter-rouge">Module</code>构建函数。所有模块都是<code class="highlighter-rouge">Module</code>的实例。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Module</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
  <span class="c1">// ...</span>
</code></pre></div></div>

<p>每个模块内部，都有一个<code class="highlighter-rouge">module</code>对象，代表当前模块。它有以下属性。</p>

<ul>
  <li><code class="highlighter-rouge">module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li>
  <li><code class="highlighter-rouge">module.filename</code> 模块的文件名，带有绝对路径。</li>
  <li><code class="highlighter-rouge">module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li>
  <li><code class="highlighter-rouge">module.parent</code> 返回一个对象，表示调用该模块的模块。</li>
  <li><code class="highlighter-rouge">module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li>
  <li><code class="highlighter-rouge">module.exports</code> 表示模块对外输出的值。</li>
</ul>

<p>下面是一个示例文件，最后一行输出module变量。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example.js</span>
<span class="kd">var</span> <span class="nx">jquery</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'jquery'</span><span class="p">);</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">jquery</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
</code></pre></div></div>

<p>执行这个文件，命令行会输出如下信息。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="nl">id</span><span class="p">:</span> <span class="s1">'.'</span><span class="p">,</span>
  <span class="nx">exports</span><span class="p">:</span> <span class="p">{</span> <span class="s1">'$'</span><span class="p">:</span> <span class="p">[</span><span class="nb">Function</span><span class="p">]</span> <span class="p">},</span>
  <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">filename</span><span class="p">:</span> <span class="s1">'/path/to/example.js'</span><span class="p">,</span>
  <span class="nx">loaded</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">children</span><span class="p">:</span>
   <span class="p">[</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="s1">'/path/to/node_modules/jquery/dist/jquery.js'</span><span class="p">,</span>
       <span class="na">exports</span><span class="p">:</span> <span class="p">[</span><span class="nb">Function</span><span class="p">],</span>
       <span class="na">parent</span><span class="p">:</span> <span class="p">[</span><span class="nx">Circular</span><span class="p">],</span>
       <span class="na">filename</span><span class="p">:</span> <span class="s1">'/path/to/node_modules/jquery/dist/jquery.js'</span><span class="p">,</span>
       <span class="na">loaded</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
       <span class="na">children</span><span class="p">:</span> <span class="p">[],</span>
       <span class="na">paths</span><span class="p">:</span> <span class="p">[</span><span class="nb">Object</span><span class="p">]</span> <span class="p">}</span> <span class="p">],</span>
  <span class="nx">paths</span><span class="p">:</span>
   <span class="p">[</span> <span class="s1">'/home/user/deleted/node_modules'</span><span class="p">,</span>
     <span class="s1">'/home/user/node_modules'</span><span class="p">,</span>
     <span class="s1">'/home/node_modules'</span><span class="p">,</span>
     <span class="s1">'/node_modules'</span> <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果在命令行下调用某个模块，比如<code class="highlighter-rouge">node something.js</code>，那么<code class="highlighter-rouge">module.parent</code>就是<code class="highlighter-rouge">null</code>。如果是在脚本之中调用，比如<code class="highlighter-rouge">require('./something.js')</code>，那么<code class="highlighter-rouge">module.parent</code>就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">module</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ran with `node something.js`</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8088</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'app listening on port 8088'</span><span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// used with `require('/.something.js')`</span>
    <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">app</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="moduleexports属性">module.exports属性</h3>

<p><code class="highlighter-rouge">module.exports</code>属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取<code class="highlighter-rouge">module.exports</code>变量。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'events'</span><span class="p">).</span><span class="nx">EventEmitter</span><span class="p">;</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="p">();</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'ready'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./a'</span><span class="p">);</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'ready'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'module a is ready'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="exports变量">exports变量</h3>

<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">exports</span> <span class="o">=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">;</span>
</code></pre></div></div>

<p>造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">exports</span><span class="p">.</span><span class="nx">area</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">r</span> <span class="o">*</span> <span class="nx">r</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">circumference</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">r</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>注意，不能直接将exports变量指向一个值，因为这样等于切断了<code class="highlighter-rouge">exports</code>与<code class="highlighter-rouge">module.exports</code>的联系。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)};</span>
</code></pre></div></div>

<p>上面这样的写法是无效的，因为<code class="highlighter-rouge">exports</code>不再指向<code class="highlighter-rouge">module.exports</code>了。</p>

<p>下面的写法也是无效的。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">exports</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">'hello'</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="s1">'Hello world'</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">hello</code>函数是无法对外输出的，因为<code class="highlighter-rouge">module.exports</code>被重新赋值了。</p>

<p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用<code class="highlighter-rouge">exports</code>输出，只能使用<code class="highlighter-rouge">module.exports</code>输出。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);};</span>
</code></pre></div></div>

<p>如果你觉得，<code class="highlighter-rouge">exports</code>与<code class="highlighter-rouge">module.exports</code>之间的区别很难分清，一个简单的处理方法，就是放弃使用<code class="highlighter-rouge">exports</code>，只使用<code class="highlighter-rouge">module.exports</code>。</p>

<h2 id="amd规范与commonjs规范的兼容性">AMD规范与CommonJS规范的兼容性</h2>

<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p>

<p>AMD规范使用define方法定义模块，下面就是一个例子：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">define</span><span class="p">([</span><span class="s1">'package/lib'</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">lib</span><span class="p">){</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="nx">lib</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'hello world!'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
  <span class="p">};</span>
<span class="p">});</span>
</code></pre></div></div>

<p>AMD规范允许输出的模块兼容CommonJS规范，这时<code class="highlighter-rouge">define</code>方法需要写成下面这样：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">define</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">someModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"someModule"</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">anotherModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"anotherModule"</span><span class="p">);</span>

  <span class="nx">someModule</span><span class="p">.</span><span class="nx">doTehAwesome</span><span class="p">();</span>
  <span class="nx">anotherModule</span><span class="p">.</span><span class="nx">doMoarAwesome</span><span class="p">();</span>

  <span class="nx">exports</span><span class="p">.</span><span class="nx">asplode</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="nx">someModule</span><span class="p">.</span><span class="nx">doTehAwesome</span><span class="p">();</span>
    <span class="nx">anotherModule</span><span class="p">.</span><span class="nx">doMoarAwesome</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">});</span>
</code></pre></div></div>

<h2 id="require命令">require命令</h2>

<h3 id="基本用法">基本用法</h3>

<p>Node使用CommonJS模块规范，内置的<code class="highlighter-rouge">require</code>命令用于加载模块文件。</p>

<p><code class="highlighter-rouge">require</code>命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example.js</span>
<span class="kd">var</span> <span class="nx">invisible</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"invisible"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="s2">"hi"</span><span class="p">;</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行下面的命令，可以输出exports对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">example</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./example.js'</span><span class="p">);</span>
<span class="nx">example</span>
<span class="c1">// {</span>
<span class="c1">//   message: "hi",</span>
<span class="c1">//   say: [Function]</span>
<span class="c1">// }</span>
</code></pre></div></div>

<p>如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在<code class="highlighter-rouge">module.exports</code>变量上面。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"hello world"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">require</span><span class="p">(</span><span class="s1">'./example2.js'</span><span class="p">)()</span>
</code></pre></div></div>

<p>上面代码中，require命令调用自身，等于是执行<code class="highlighter-rouge">module.exports</code>，因此会输出 hello world。</p>

<h3 id="加载规则">加载规则</h3>

<p><code class="highlighter-rouge">require</code>命令用于加载文件，后缀名默认为<code class="highlighter-rouge">.js</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">);</span>
<span class="c1">//  等同于</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'foo.js'</span><span class="p">);</span>
</code></pre></div></div>

<p>根据参数的不同格式，<code class="highlighter-rouge">require</code>命令去不同路径寻找模块文件。</p>

<p>（1）如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，<code class="highlighter-rouge">require('/home/marco/foo.js')</code>将加载<code class="highlighter-rouge">/home/marco/foo.js</code>。</p>

<p>（2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，<code class="highlighter-rouge">require('./circle')</code>将加载当前脚本同一目录的<code class="highlighter-rouge">circle.js</code>。</p>

<p>（3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p>

<p>举例来说，脚本<code class="highlighter-rouge">/home/user/projects/foo.js</code>执行了<code class="highlighter-rouge">require('bar.js')</code>命令，Node会依次搜索以下文件。</p>

<ul>
  <li>/usr/local/lib/node/bar.js</li>
  <li>/home/user/projects/node_modules/bar.js</li>
  <li>/home/user/node_modules/bar.js</li>
  <li>/home/node_modules/bar.js</li>
  <li>/node_modules/bar.js</li>
</ul>

<p>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p>

<p>（4）如果参数字符串不以“./“或”/“开头，而且是一个路径，比如<code class="highlighter-rouge">require('example-module/path/to/file')</code>，则将先找到<code class="highlighter-rouge">example-module</code>的位置，然后再以它为参数，找到后续路径。</p>

<p>（5）如果指定的模块文件没有发现，Node会尝试为文件名添加<code class="highlighter-rouge">.js</code>、<code class="highlighter-rouge">.json</code>、<code class="highlighter-rouge">.node</code>后，再去搜索。<code class="highlighter-rouge">.js</code>件会以文本格式的JavaScript脚本文件解析，<code class="highlighter-rouge">.json</code>文件会以JSON格式的文本文件解析，<code class="highlighter-rouge">.node</code>文件会以编译后的二进制文件解析。</p>

<p>（6）如果想得到<code class="highlighter-rouge">require</code>命令加载的确切文件名，使用<code class="highlighter-rouge">require.resolve()</code>方法。</p>

<h3 id="目录的加载规则">目录的加载规则</h3>

<p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让<code class="highlighter-rouge">require</code>方法可以通过这个入口文件，加载整个目录。</p>

<p>在目录中放置一个<code class="highlighter-rouge">package.json</code>文件，并且将入口文件写入<code class="highlighter-rouge">main</code>字段。下面是一个例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// package.json</span>
<span class="p">{</span> <span class="s2">"name"</span> <span class="p">:</span> <span class="s2">"some-library"</span><span class="p">,</span>
  <span class="s2">"main"</span> <span class="p">:</span> <span class="s2">"./lib/some-library.js"</span> <span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">require</code>发现参数字符串指向一个目录以后，会自动查看该目录的<code class="highlighter-rouge">package.json</code>文件，然后加载<code class="highlighter-rouge">main</code>字段指定的入口文件。如果<code class="highlighter-rouge">package.json</code>文件没有<code class="highlighter-rouge">main</code>字段，或者根本就没有<code class="highlighter-rouge">package.json</code>文件，则会加载该目录下的<code class="highlighter-rouge">index.js</code>文件或<code class="highlighter-rouge">index.node</code>文件。</p>

<h3 id="模块的缓存">模块的缓存</h3>

<p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的<code class="highlighter-rouge">module.exports</code>属性。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">require</span><span class="p">(</span><span class="s1">'./example.js'</span><span class="p">);</span>
<span class="nx">require</span><span class="p">(</span><span class="s1">'./example.js'</span><span class="p">).</span><span class="nx">message</span> <span class="o">=</span> <span class="s2">"hello"</span><span class="p">;</span>
<span class="nx">require</span><span class="p">(</span><span class="s1">'./example.js'</span><span class="p">).</span><span class="nx">message</span>
<span class="c1">// "hello"</span>
</code></pre></div></div>

<p>上面代码中，连续三次使用<code class="highlighter-rouge">require</code>命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个<code class="highlighter-rouge">message</code>属性。但是第三次加载的时候，这个message属性依然存在，这就证明<code class="highlighter-rouge">require</code>命令并没有重新加载模块文件，而是输出了缓存。</p>

<p>如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次<code class="highlighter-rouge">require</code>这个模块的时候，重新执行一下输出的函数。</p>

<p>所有缓存的模块保存在<code class="highlighter-rouge">require.cache</code>之中，如果想删除模块的缓存，可以像下面这样写。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 删除指定模块的缓存</span>
<span class="k">delete</span> <span class="nx">require</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">moduleName</span><span class="p">];</span>

<span class="c1">// 删除所有模块的缓存</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">require</span><span class="p">.</span><span class="nx">cache</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">delete</span> <span class="nx">require</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">})</span>
</code></pre></div></div>

<p>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，<code class="highlighter-rouge">require</code>命令还是会重新加载该模块。</p>

<h3 id="环境变量node_path">环境变量NODE_PATH</h3>

<p>Node执行一个脚本时，会先查看环境变量<code class="highlighter-rouge">NODE_PATH</code>。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。</p>

<p>可以将NODE_PATH添加到<code class="highlighter-rouge">.bashrc</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">NODE_PATH</span><span class="o">=</span><span class="s2">"/usr/local/lib/node"</span>
</code></pre></div></div>

<p>所以，如果遇到复杂的相对路径，比如下面这样。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'../../../../lib/myModule'</span><span class="p">);</span>
</code></pre></div></div>

<p>有两种解决方法，一是将该文件加入<code class="highlighter-rouge">node_modules</code>目录，二是修改<code class="highlighter-rouge">NODE_PATH</code>环境变量，<code class="highlighter-rouge">package.json</code>文件可以采用下面的写法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"node_path"</span><span class="p">,</span>
  <span class="s2">"version"</span><span class="p">:</span> <span class="s2">"1.0.0"</span><span class="p">,</span>
  <span class="s2">"description"</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span>
  <span class="s2">"main"</span><span class="p">:</span> <span class="s2">"index.js"</span><span class="p">,</span>
  <span class="s2">"scripts"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"start"</span><span class="p">:</span> <span class="s2">"NODE_PATH=lib node index.js"</span>
  <span class="p">},</span>
  <span class="s2">"author"</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span>
  <span class="s2">"license"</span><span class="p">:</span> <span class="s2">"ISC"</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">NODE_PATH</code>是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用<code class="highlighter-rouge">node_modules</code>目录机制。</p>

<h3 id="模块的循环加载">模块的循环加载</h3>

<p>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a.js</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'a1'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'a.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./b.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'a2'</span><span class="p">;</span>

<span class="c1">// b.js</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'b1'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'b.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./a.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'b2'</span><span class="p">;</span>

<span class="c1">// main.js</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./a.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./b.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node main.js
b.js  a1
a.js  b2
main.js  a2
main.js  b2
</code></pre></div></div>

<p>修改main.js，再次加载a.js和b.js。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.js</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./a.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./b.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./a.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'main.js '</span><span class="p">,</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./b.js'</span><span class="p">).</span><span class="nx">x</span><span class="p">);</span>
</code></pre></div></div>

<p>执行上面代码，结果如下。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node main.js
b.js  a1
a.js  b2
main.js  a2
main.js  b2
main.js  a2
main.js  b2
</code></pre></div></div>

<p>上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。</p>

<h3 id="requiremain">require.main</h3>

<p><code class="highlighter-rouge">require</code>方法有一个<code class="highlighter-rouge">main</code>属性，可以用来判断模块是直接执行，还是被调用执行。</p>

<p>直接执行的时候（<code class="highlighter-rouge">node module.js</code>），<code class="highlighter-rouge">require.main</code>属性指向模块本身。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">require</span><span class="p">.</span><span class="nx">main</span> <span class="o">===</span> <span class="nx">module</span>
<span class="c1">// true</span>
</code></pre></div></div>

<p>调用执行的时候（通过<code class="highlighter-rouge">require</code>加载该脚本执行），上面的表达式返回false。</p>

<h2 id="模块的加载机制">模块的加载机制</h2>

<p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p>

<p>下面是一个模块文件<code class="highlighter-rouge">lib.js</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lib.js</span>
<span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">incCounter</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">counter</span><span class="p">:</span> <span class="nx">counter</span><span class="p">,</span>
  <span class="na">incCounter</span><span class="p">:</span> <span class="nx">incCounter</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上面代码输出内部变量<code class="highlighter-rouge">counter</code>和改写这个变量的内部方法<code class="highlighter-rouge">incCounter</code>。</p>

<p>然后，加载上面的模块。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.js</span>
<span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./lib'</span><span class="p">).</span><span class="nx">counter</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">incCounter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./lib'</span><span class="p">).</span><span class="nx">incCounter</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">);</span>  <span class="c1">// 3</span>
<span class="nx">incCounter</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">);</span> <span class="c1">// 3</span>
</code></pre></div></div>

<p>上面代码说明，<code class="highlighter-rouge">counter</code>输出以后，<code class="highlighter-rouge">lib.js</code>模块内部的变化就影响不到<code class="highlighter-rouge">counter</code>了。</p>

<h3 id="require的内部处理流程">require的内部处理流程</h3>

<p><code class="highlighter-rouge">require</code>命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的<code class="highlighter-rouge">module.require</code>命令，而后者又调用Node的内部命令<code class="highlighter-rouge">Module._load</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Module</span><span class="p">.</span><span class="nx">_load</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">isMain</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. 检查 Module._cache，是否缓存之中有指定模块</span>
  <span class="c1">// 2. 如果缓存之中没有，就创建一个新的Module实例</span>
  <span class="c1">// 3. 将它保存到缓存</span>
  <span class="c1">// 4. 使用 module.load() 加载指定的模块文件，</span>
  <span class="c1">//    读取文件内容之后，使用 module.compile() 执行文件代码</span>
  <span class="c1">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span>
  <span class="c1">// 6. 返回该模块的 module.exports</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上面的第4步，采用<code class="highlighter-rouge">module.compile()</code>执行指定模块的脚本，逻辑如下。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Module</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_compile</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. 生成一个require函数，指向module.require</span>
  <span class="c1">// 2. 加载其他辅助方法到require</span>
  <span class="c1">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span>
  <span class="c1">// 4. 执行该函数</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上面的第1步和第2步，<code class="highlighter-rouge">require</code>函数及其辅助方法主要如下。</p>

<ul>
  <li><code class="highlighter-rouge">require()</code>: 加载外部模块</li>
  <li><code class="highlighter-rouge">require.resolve()</code>：将模块名解析到一个绝对路径</li>
  <li><code class="highlighter-rouge">require.main</code>：指向主模块</li>
  <li><code class="highlighter-rouge">require.cache</code>：指向所有缓存的模块</li>
  <li><code class="highlighter-rouge">require.extensions</code>：根据文件的后缀名，调用不同的执行函数</li>
</ul>

<p>一旦<code class="highlighter-rouge">require</code>函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括<code class="highlighter-rouge">require</code>、<code class="highlighter-rouge">module</code>、<code class="highlighter-rouge">exports</code>，以及其他一些参数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">exports</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">module</span><span class="p">,</span> <span class="nx">__filename</span><span class="p">,</span> <span class="nx">__dirname</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// YOUR CODE INJECTED HERE!</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Module._compile</code>方法是同步执行的，所以<code class="highlighter-rouge">Module._load</code>要等它执行完成，才会向用户返回<code class="highlighter-rouge">module.exports</code>的值。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>Addy Osmani, <a href="http://addyosmani.com/writing-modular-js/">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</a></li>
  <li>Pony Foo, <a href="http://blog.ponyfoo.com/2014/08/25/a-gentle-browserify-walkthrough">A Gentle Browserify Walkthrough</a></li>
  <li>Nico Reed, <a href="https://docs.nodejitsu.com/articles/getting-started/what-is-require">What is require?</a></li>
  <li>Fred K. Schott, <a href="http://fredkschott.com/post/2014/06/require-and-the-module-system/">The Node.js Way - How require() Actually Works</a></li>
</ul>


</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="/introduction/license.html">版权声明</a> | last modified on 2013-08-13 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


