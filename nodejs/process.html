<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>process对象 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="/js/jquery.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="/#introduction">导论</a></li>
			
			<li><a href="/#grammar">语法</a></li>
			
			<li><a href="/#stdlib">标准库</a></li>
			
			<li><a href="/#oop">面向对象编程</a></li>
			
			<li><a href="/#advanced">语法专题</a></li>
			
			<li><a href="/#dom">DOM模型</a></li>
			
			<li><a href="/#bom">浏览器环境</a></li>
			
			<li><a href="/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> 草稿二：Node.js </a><ul class="dropdown">













<li><a href="/nodejs/assert.html">assert 模块</a></li>













<li><a href="/nodejs/basic.html">Node.js 概述</a></li>













<li><a href="/nodejs/buffer.html">Buffer对象</a></li>





<li><a href="/nodejs/child-process.html">Child Process模块</a></li>





<li><a href="/nodejs/cluster.html">Cluster模块</a></li>

























<li><a href="/nodejs/develop.html">Node应用程序开发</a></li>





<li><a href="/nodejs/dns.html">dns 模块</a></li>





















<li><a href="/nodejs/events.html">Events模块</a></li>







<li><a href="/nodejs/express.html">Express框架</a></li>









<li><a href="/nodejs/fs.html">fs 模块</a></li>



















<li><a href="/nodejs/http.html">Http模块</a></li>



















<li><a href="/nodejs/koa.html">Koa 框架</a></li>

















<li><a href="/nodejs/module.html">CommonJS规范</a></li>





<li><a href="/nodejs/mongodb.html">MongoDB的应用</a></li>







<li><a href="/nodejs/net.html">Net模块和DNS模块</a></li>









<li><a href="/nodejs/npm.html">npm模块管理器</a></li>

















<li><a href="/nodejs/os.html">os模块</a></li>





<li><a href="/nodejs/packagejson.html">package.json文件</a></li>







<li><a href="/nodejs/path.html">Path模块</a></li>















<li class="active"><a href="#">process对象</a></li>











<li><a href="/nodejs/querystring.html">querystring 模块</a></li>





















<li><a href="/nodejs/stream.html">Stream接口</a></li>



























<li><a href="/nodejs/url.html">url 模块</a></li>





















</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> process对象</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> process对象 </h1>

<aside class="right"><p>来自<a href="/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<p><code class="highlighter-rouge">process</code>对象是 Node 的一个全局对象，提供当前 Node 进程的信息。它可以在脚本的任意位置使用，不必通过<code class="highlighter-rouge">require</code>命令加载。该对象部署了<code class="highlighter-rouge">EventEmitter</code>接口。</p>

<h2 id="属性">属性</h2>

<p><code class="highlighter-rouge">process</code>对象提供一系列属性，用于返回系统信息。</p>

<ul>
  <li><code class="highlighter-rouge">process.argv</code>：返回一个数组，成员是当前进程的所有命令行参数。</li>
  <li><code class="highlighter-rouge">process.env</code>：返回一个对象，成员为当前Shell的环境变量，比如<code class="highlighter-rouge">process.env.HOME</code>。</li>
  <li><code class="highlighter-rouge">process.installPrefix</code>：返回一个字符串，表示 Node 安装路径的前缀，比如<code class="highlighter-rouge">/usr/local</code>。相应地，Node 的执行文件目录为<code class="highlighter-rouge">/usr/local/bin/node</code>。</li>
  <li><code class="highlighter-rouge">process.pid</code>：返回一个数字，表示当前进程的进程号。</li>
  <li><code class="highlighter-rouge">process.platform</code>：返回一个字符串，表示当前的操作系统，比如<code class="highlighter-rouge">Linux</code>。</li>
  <li><code class="highlighter-rouge">process.title</code>：返回一个字符串，默认值为<code class="highlighter-rouge">node</code>，可以自定义该值。</li>
  <li><code class="highlighter-rouge">process.version</code>：返回一个字符串，表示当前使用的 Node 版本，比如<code class="highlighter-rouge">v7.10.0</code>。</li>
</ul>

<p><code class="highlighter-rouge">process</code>对象还有一些属性，用来指向 Shell 提供的接口。</p>

<h3 id="processstdout">process.stdout</h3>

<p><code class="highlighter-rouge">process.stdout</code>属性返回一个对象，表示标准输出。该对象的<code class="highlighter-rouge">write</code>方法等同于<code class="highlighter-rouge">console.log</code>，可用在标准输出向用户显示内容。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">d</span> <span class="o">+</span> <span class="s1">'</span><span class="err">\</span><span class="s1">n'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>下面代码表示将一个文件导向标准输出。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">'wow.txt'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，由于<code class="highlighter-rouge">process.stdout</code>和<code class="highlighter-rouge">process.stdin</code>与其他进程的通信，都是流（stream）形式，所以必须通过<code class="highlighter-rouge">pipe</code>管道命令中介。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">zlib</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'zlib'</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="s1">'wow.txt'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">zlib</span><span class="p">.</span><span class="nx">createGzip</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码通过<code class="highlighter-rouge">pipe</code>方法，先将文件数据压缩，然后再导向标准输出。</p>

<h3 id="processstdin">process.stdin</h3>

<p><code class="highlighter-rouge">process.stdin</code>返回一个对象，表示标准输入。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码表示将标准输入导向标准输出。</p>

<p>由于stdin和stdout都部署了stream接口，所以可以使用stream接口的方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">'utf8'</span><span class="p">);</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'readable'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">'data: '</span> <span class="o">+</span> <span class="nx">chunk</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">'end'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="stderr">stderr</h3>

<p><code class="highlighter-rouge">process.stderr</code>属性指向标准错误。</p>

<h3 id="processargvprocessexecpathprocessexecargv">process.argv，process.execPath，process.execArgv</h3>

<p><code class="highlighter-rouge">process.argv</code>属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是<code class="highlighter-rouge">node</code>，第二个成员是脚本文件名，其余成员是脚本文件的参数。</p>

<p>请看下面的例子，新建一个脚本文件<code class="highlighter-rouge">argv.js</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// argv.js</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"argv: "</span><span class="p">,</span> <span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">);</span>
</code></pre></div></div>

<p>命令行下调用这个脚本，会得到以下结果。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span> <span class="nx">node</span> <span class="nx">argv</span><span class="p">.</span><span class="nx">js</span> <span class="nx">a</span> <span class="nx">b</span> <span class="nx">c</span>
<span class="p">[</span> <span class="s1">'node'</span><span class="p">,</span> <span class="s1">'/path/to/argv.js'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span> <span class="p">]</span>
</code></pre></div></div>

<p>上面代码表示，<code class="highlighter-rouge">argv</code>返回数组的成员依次是命令行的各个部分，真正的参数实际上是从<code class="highlighter-rouge">process.argv[2]</code>开始。要得到真正的参数部分，可以把<code class="highlighter-rouge">argv.js</code>改写成下面这样。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// argv.js</span>
<span class="kd">var</span> <span class="nx">myArgs</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myArgs</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">process.execPath</code>属性返回执行当前脚本的Node二进制文件的绝对路径。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nx">process</span><span class="p">.</span><span class="nx">execPath</span>
<span class="s1">'/usr/local/bin/node'</span>
<span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">process.execArgv</code>属性返回一个数组，成员是命令行下执行脚本时，在 Node 可执行文件与脚本文件之间的命令行参数。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># script.js的代码为</span>
<span class="c"># console.log(process.execArgv);</span>
<span class="nv">$ </span>node <span class="nt">--harmony</span> script.js <span class="nt">--version</span>
</code></pre></div></div>

<h3 id="processenv">process.env</h3>

<p><code class="highlighter-rouge">process.env</code>属性返回一个对象，包含了当前Shell的所有环境变量。比如，<code class="highlighter-rouge">process.env.HOME</code>返回用户的主目录。</p>

<p>通常的做法是，新建一个环境变量<code class="highlighter-rouge">NODE_ENV</code>，用它确定当前所处的开发阶段，生产阶段设为<code class="highlighter-rouge">production</code>，开发阶段设为<code class="highlighter-rouge">develop</code>或<code class="highlighter-rouge">staging</code>，然后在脚本中读取<code class="highlighter-rouge">process.env.NODE_ENV</code>即可。</p>

<p>运行脚本时，改变环境变量，可以采用下面的写法。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">NODE_ENV</span><span class="o">=</span>production <span class="o">&amp;&amp;</span> node app.js
<span class="c"># 或者</span>
<span class="nv">$ NODE_ENV</span><span class="o">=</span>production node app.js
</code></pre></div></div>

<h2 id="方法">方法</h2>

<p><code class="highlighter-rouge">process</code>对象提供以下方法：</p>

<ul>
  <li><code class="highlighter-rouge">process.chdir()</code>：切换工作目录到指定目录。</li>
  <li><code class="highlighter-rouge">process.cwd()</code>：返回运行当前脚本的工作目录的路径。</li>
  <li><code class="highlighter-rouge">process.exit()</code>：退出当前进程。</li>
  <li><code class="highlighter-rouge">process.getgid()</code>：返回当前进程的组ID（数值）。</li>
  <li><code class="highlighter-rouge">process.getuid()</code>：返回当前进程的用户ID（数值）。</li>
  <li><code class="highlighter-rouge">process.nextTick()</code>：指定回调函数在当前执行栈的尾部、下一次Event Loop之前执行。</li>
  <li><code class="highlighter-rouge">process.on()</code>：监听事件。</li>
  <li><code class="highlighter-rouge">process.setgid()</code>：指定当前进程的组，可以使用数字ID，也可以使用字符串ID。</li>
  <li><code class="highlighter-rouge">process.setuid()</code>：指定当前进程的用户，可以使用数字ID，也可以使用字符串ID。</li>
</ul>

<h3 id="processcwdprocesschdir">process.cwd()，process.chdir()</h3>

<p><code class="highlighter-rouge">cwd</code>方法返回进程的当前目录（绝对路径），<code class="highlighter-rouge">chdir</code>方法用来切换目录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> process.cwd<span class="o">()</span>
<span class="s1">'/home/aaa'</span>

<span class="o">&gt;</span> process.chdir<span class="o">(</span><span class="s1">'/home/bbb'</span><span class="o">)</span>
<span class="o">&gt;</span> process.cwd<span class="o">()</span>
<span class="s1">'/home/bbb'</span>
</code></pre></div></div>

<p>注意，<code class="highlighter-rouge">process.cwd()</code>与<code class="highlighter-rouge">__dirname</code>的区别。前者进程发起时的位置，后者是脚本的位置，两者可能是不一致的。比如，<code class="highlighter-rouge">node ./code/program.js</code>，对于<code class="highlighter-rouge">process.cwd()</code>来说，返回的是当前目录（<code class="highlighter-rouge">.</code>）；对于<code class="highlighter-rouge">__dirname</code>来说，返回是脚本所在目录，即<code class="highlighter-rouge">./code/program.js</code>。</p>

<h2 id="processnexttick">process.nextTick()</h2>

<p><code class="highlighter-rouge">process.nextTick</code>将任务放到当前一轮事件循环（Event Loop）的尾部。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>process.nextTick<span class="o">(</span><span class="k">function</span> <span class="o">()</span> <span class="o">{</span>
  console.log<span class="o">(</span><span class="s1">'下一次Event Loop即将开始!'</span><span class="o">)</span><span class="p">;</span>
<span class="o">})</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码可以用<code class="highlighter-rouge">setTimeout(f,0)</code>改写，效果接近，但是原理不同。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout<span class="o">(</span><span class="k">function</span> <span class="o">()</span> <span class="o">{</span>
  console.log<span class="o">(</span><span class="s1">'已经到了下一轮Event Loop！'</span><span class="o">)</span><span class="p">;</span>
<span class="o">}</span>, 0<span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">setTimeout(f,0)</code>是将任务放到下一轮事件循环的头部，因此<code class="highlighter-rouge">nextTick</code>会比它先执行。另外，<code class="highlighter-rouge">nextTick</code>的效率更高，因为不用检查是否到了指定时间。</p>

<p>根据Node的事件循环的实现，基本上，进入下一轮事件循环后的执行顺序如下。</p>

<ol>
  <li><code class="highlighter-rouge">setTimeout(f,0)</code></li>
  <li>各种到期的回调函数</li>
  <li><code class="highlighter-rouge">process.nextTick</code>
push(), sort(), reverse(), and splice()</li>
</ol>

<h3 id="processexit">process.exit()</h3>

<p><code class="highlighter-rouge">process.exit</code>方法用来退出当前进程。它可以接受一个数值参数，如果参数大于0，表示执行失败；如果等于0表示执行成功。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果不带有参数，<code class="highlighter-rouge">exit</code>方法的参数默认为0。</p>

<p>注意，<code class="highlighter-rouge">process.exit()</code>很多时候是不需要的。因为如果没有错误，一旦事件循环之中没有待完成的任务，Node 本来就会退出进程，不需要调用<code class="highlighter-rouge">process.exit(0)</code>。这时如果调用了，进程会立刻退出，不管有没有异步任务还在执行，所以不如等 Node 自然退出。另一方面，如果发生错误，Node 往往也会退出进程，也不一定要调用<code class="highlighter-rouge">process.exit(1)</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printUsageStdout</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">'...some long text ...'</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">printUsageToStdout</span><span class="p">();</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码可能不会达到预期效果。因为<code class="highlighter-rouge">process.stdout</code>有时会变成异步，不能保证一定会在当前事件循环之中输出所有内容，而<code class="highlighter-rouge">process.exit</code>会使当前进程立刻退出。</p>

<p>更安全的方法是使用<code class="highlighter-rouge">exitcode</code>属性，指定退出状态，然后再抛出一个错误。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">printUsageToStdout</span><span class="p">();</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exitCode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"xx condition failed"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">process.exit()</code>执行时，会触发<code class="highlighter-rouge">exit</code>事件。</p>

<h3 id="processon">process.on()</h3>

<p><code class="highlighter-rouge">process</code>对象部署了EventEmitter接口，可以使用<code class="highlighter-rouge">on</code>方法监听各种事件，并指定回调函数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'uncaughtException'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'got an error: %s'</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'fail'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码是<code class="highlighter-rouge">process</code>监听Node的一个全局性事件<code class="highlighter-rouge">uncaughtException</code>，只要有错误没有捕获，就会触发这个事件。</p>

<p><code class="highlighter-rouge">process</code>支持的事件还有下面这些。</p>

<ul>
  <li><code class="highlighter-rouge">data</code>事件：数据输出输入时触发</li>
  <li><code class="highlighter-rouge">SIGINT</code>事件：接收到系统信号<code class="highlighter-rouge">SIGINT</code>时触发，主要是用户按<code class="highlighter-rouge">Ctrl + c</code>时触发。</li>
  <li><code class="highlighter-rouge">SIGTERM</code>事件：系统发出进程终止信号<code class="highlighter-rouge">SIGTERM</code>时触发</li>
  <li><code class="highlighter-rouge">exit</code>事件：进程退出前触发</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'SIGINT'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Got a SIGINT. Goodbye cruel world'</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 也可以忽略这个信号</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'SIGINT'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Ignored Ctrl-C"</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>使用时，向该进程发出系统信号，就会导致进程退出。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">kill</span> <span class="nt">-s</span> SIGINT <span class="o">[</span>process_id]
</code></pre></div></div>

<p><code class="highlighter-rouge">SIGTERM</code>信号表示内核要求当前进程停止，进程可以自行停止，也可以忽略这个信号。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">});</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'SIGTERM'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">server</span><span class="p">.</span><span class="nx">close</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

</code></pre></div></div>

<p>上面代码表示，进程接到<code class="highlighter-rouge">SIGTERM</code>信号之后，关闭服务器，然后退出进程。需要注意的是，这时进程不会马上退出，而是要回应完最后一个请求，处理完所有回调函数，然后再退出。</p>

<p><code class="highlighter-rouge">exit</code>事件在Node进程退出前触发。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'exit'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Goodbye'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="processkill">process.kill()</h3>

<p><code class="highlighter-rouge">process.kill</code>方法用来对指定ID的线程发送信号，默认为<code class="highlighter-rouge">SIGINT</code>信号。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">kill</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="s1">'SIGTERM'</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码用于杀死当前进程。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'SIGTERM'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'terminating'</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'sending SIGTERM to process %d'</span><span class="p">,</span> <span class="nx">process</span><span class="p">.</span><span class="nx">pid</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">kill</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">pid</span><span class="p">,</span> <span class="s1">'SIGTERM'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">500</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'never called'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，500毫秒后向当前进程发送SIGTERM信号（终结进程），因此1000毫秒后的指定事件不会被触发。</p>

<h2 id="事件">事件</h2>

<h3 id="exit事件">exit事件</h3>

<p>当前进程退出时，会触发<code class="highlighter-rouge">exit</code>事件，可以对该事件指定回调函数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'exit'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">writeFileSync</span><span class="p">(</span><span class="s1">'/tmp/myfile'</span><span class="p">,</span> <span class="s1">'需要保存到硬盘的信息'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>下面是一个例子，进程退出时，显示一段日志。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"exit"</span><span class="p">,</span> <span class="nx">code</span> <span class="o">=&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"exiting with code: "</span> <span class="o">+</span> <span class="nx">code</span><span class="p">))</span>
</code></pre></div></div>

<p>注意，此时回调函数只能执行同步操作，不能包含异步操作，因为执行完回调函数，进程就会退出，无法监听到回调函数的操作结果。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'exit'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 不会执行</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'This will not run'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码在<code class="highlighter-rouge">exit</code>事件的回调函数里面，指定了一个下一轮事件循环，所要执行的操作。这是无效的，不会得到执行。</p>

<h3 id="beforeexit事件">beforeExit事件</h3>

<p>beforeExit事件在Node清空了Event Loop以后，再没有任何待处理的任务时触发。正常情况下，如果没有任何待处理的任务，Node进程会自动退出，设置beforeExit事件的监听函数以后，就可以提供一个机会，再部署一些任务，使得Node进程不退出。</p>

<p>beforeExit事件与exit事件的主要区别是，beforeExit的监听函数可以部署异步任务，而exit不行。</p>

<p>此外，如果是显式终止程序（比如调用process.exit()），或者因为发生未捕获的错误，而导致进程退出，这些场合不会触发beforeExit事件。因此，不能使用该事件替代exit事件。</p>

<h3 id="uncaughtexception事件">uncaughtException事件</h3>

<p>当前进程抛出一个没有被捕捉的错误时，会触发<code class="highlighter-rouge">uncaughtException</code>事件。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'uncaughtException'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'An uncaught error occurred!'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">stack</span><span class="p">);</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'未捕获错误'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>部署<code class="highlighter-rouge">uncaughtException</code>事件的监听函数，是免于Node进程终止的最后措施，否则Node就要执行<code class="highlighter-rouge">process.exit()</code>。出于除错的目的，并不建议发生错误后，还保持进程运行。</p>

<p>抛出错误之前部署的异步操作，还是会继续执行。只有完成以后，Node进程才会退出。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'uncaughtException'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Caught exception: '</span> <span class="o">+</span> <span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'本行依然执行'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">500</span><span class="p">);</span>

<span class="c1">// 下面的表达式抛出错误</span>
<span class="nx">nonexistentFunc</span><span class="p">();</span>
</code></pre></div></div>

<p>上面代码中，抛出错误之后，此前setTimeout指定的回调函数亦然会执行。</p>

<h3 id="信号事件">信号事件</h3>

<p>操作系统内核向Node进程发出信号，会触发信号事件。实际开发中，主要对SIGTERM和SIGINT信号部署监听函数，这两个信号在非Windows平台会导致进程退出，但是只要部署了监听函数，Node进程收到信号后就不会退出。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 读取标准输入，这主要是为了不让当前进程退出</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">resume</span><span class="p">();</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'SIGINT'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'SIGINT信号，按Control-D退出'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码部署了SIGINT信号的监听函数，当用户按下Ctrl-C后，会显示提示文字。</p>

<h2 id="进程的退出码">进程的退出码</h2>

<p>进程退出时，会返回一个整数值，表示退出时的状态。这个整数值就叫做退出码。下面是常见的Node进程退出码。</p>

<ul>
  <li>0，正常退出</li>
  <li>1，发生未捕获错误</li>
  <li>5，V8执行错误</li>
  <li>8，不正确的参数</li>
  <li>128 + 信号值，如果Node接受到退出信号（比如SIGKILL或SIGHUP），它的退出码就是128加上信号值。由于128的二进制形式是10000000, 所以退出码的后七位就是信号值。</li>
</ul>

<p>Bash可以使用环境变量<code class="highlighter-rouge">$?</code>，获取上一步操作的退出码。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node nonexist.js
Error: Cannot find <span class="s1">'nonexist.js'</span>

<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</code></pre></div></div>

<p>上面代码中，Node执行一个不存在的脚本文件，结果报错，退出码就是1。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>José F. Romaniello, <a href="http://joseoncode.com/2014/07/21/graceful-shutdown-in-node-dot-js/">Graceful shutdown in node.js</a></li>
</ul>


</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="/introduction/license.html">版权声明</a> | last modified on 2014-10-20 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


