<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width" />

  <title>定时器 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="/js/jquery.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/main.js"></script>

</head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="/#introduction">导论</a></li>
			
			<li><a href="/#grammar">语法</a></li>
			
			<li><a href="/#stdlib">标准库</a></li>
			
			<li><a href="/#oop">面向对象编程</a></li>
			
			<li><a href="/#advanced">语法专题</a></li>
			
			<li><a href="/#dom">DOM模型</a></li>
			
			<li><a href="/#bom">浏览器环境</a></li>
			
			<li><a href="/#htmlapi">Web API</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="#"> 语法专题 </a><ul class="dropdown">



















<li><a href="/advanced/backbonejs.html">MVC框架与Backbone.js</a></li>

















































<li><a href="/advanced/ecmascript6.html">ECMAScript 6 介绍</a></li>





























<li><a href="/advanced/fsm.html">JavaScript与有限状态机</a></li>

























<li><a href="/advanced/interpreter.html">JavaScript解释器</a></li>









































































<li><a href="/advanced/promise.html">Promise 对象</a></li>



















<li><a href="/advanced/single-thread.html">异步操作概述</a></li>











<li><a href="/advanced/strict.html">严格模式</a></li>



















<li class="active"><a href="#">定时器</a></li>



























</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="#"> 定时器</a><ul class="dropdown">
</ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> 定时器 </h1>

<aside class="right"><p>来自<a href="/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<div id="toc" class="panel callout radius">目录</div>


<p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由<code class="highlighter-rouge">setTimeout()</code>和<code class="highlighter-rouge">setInterval()</code>这两个函数来完成。它们向任务队列添加定时任务。</p>

<h2 id="settimeout">setTimeout()</h2>

<p><code class="highlighter-rouge">setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">timerId</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="o">|</span><span class="nx">code</span><span class="p">,</span> <span class="nx">delay</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">setTimeout</code>函数接受两个参数，第一个参数<code class="highlighter-rouge">func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code class="highlighter-rouge">delay</code>是推迟执行的毫秒数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="s1">'console.log(2)'</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// 1</span>
<span class="c1">// 3</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<p>上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，<code class="highlighter-rouge">console.log(2)</code>必须以字符串的形式，作为<code class="highlighter-rouge">setTimeout</code>的参数。</p>

<p>如果推迟执行的是函数，就直接将函数名，作为<code class="highlighter-rouge">setTimeout</code>的参数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">setTimeout</code>的第二个参数如果省略，则默认为0。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="c1">// 等同于</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>除了前两个参数，<code class="highlighter-rouge">setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">setTimeout</code>共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p>

<p>还有一个需要注意的地方，如果回调函数是对象的方法，那么<code class="highlighter-rouge">setTimeout</code>使得方法内部的<code class="highlighter-rouge">this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="na">y</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p>上面代码输出的是1，而不是2。因为当<code class="highlighter-rouge">obj.y</code>在1000毫秒后运行时，<code class="highlighter-rouge">this</code>所指向的已经不是<code class="highlighter-rouge">obj</code>了，而是全局环境。</p>

<p>为了防止出现这个问题，一种解决方法是将<code class="highlighter-rouge">obj.y</code>放入一个函数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="na">y</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">obj.y</code>放在一个匿名函数之中，这使得<code class="highlighter-rouge">obj.y</code>在<code class="highlighter-rouge">obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p>

<p>另一种解决方法是，使用<code class="highlighter-rouge">bind</code>方法，将<code class="highlighter-rouge">obj.y</code>这个方法绑定在<code class="highlighter-rouge">obj</code>上面。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="na">y</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
<span class="c1">// 2</span>
</code></pre></div></div>

<h2 id="setinterval">setInterval()</h2>

<p><code class="highlighter-rouge">setInterval</code>函数的用法与<code class="highlighter-rouge">setTimeout</code>完全一致，区别仅仅在于<code class="highlighter-rouge">setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</p>

<p>与<code class="highlighter-rouge">setTimeout</code>一样，除了前两个参数，<code class="highlighter-rouge">setInterval</code>方法还可以接受更多的参数，它们会传入回调函数。</p>

<p>下面是一个通过<code class="highlighter-rouge">setInterval</code>方法实现网页动画的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'someDiv'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">fader</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="nx">opacity</span> <span class="o">-=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nx">opacity</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">=</span> <span class="nx">opacity</span><span class="p">;</span>
<span class="err">  </span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">fader</span><span class="p">);</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码每隔100毫秒，设置一次<code class="highlighter-rouge">div</code>元素的透明度，直至其完全透明为止。</p>

<p><code class="highlighter-rouge">setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">hash</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">hashWatcher</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="err">  </span><span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span> <span class="o">!=</span> <span class="nx">hash</span><span class="p">)</span> <span class="p">{</span>
<span class="err">    </span><span class="nx">updatePage</span><span class="p">();</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code class="highlighter-rouge">setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p>

<p>为了确保两次执行之间有固定的间隔，可以不用<code class="highlighter-rouge">setInterval</code>，而是每次执行结束后，使用<code class="highlighter-rouge">setTimeout</code>指定下一次执行的具体时间。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</p>

<h2 id="cleartimeoutclearinterval">clearTimeout()，clearInterval()</h2>

<p><code class="highlighter-rouge">setTimeout</code>和<code class="highlighter-rouge">setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code class="highlighter-rouge">clearTimeout</code>和<code class="highlighter-rouge">clearInterval</code>函数，就可以取消对应的定时器。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">id1</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">id2</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

<span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">id1</span><span class="p">);</span>
<span class="nx">clearInterval</span><span class="p">(</span><span class="nx">id2</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，回调函数<code class="highlighter-rouge">f</code>不会再执行了，因为两个定时器都被取消了。</p>

<p><code class="highlighter-rouge">setTimeout</code>和<code class="highlighter-rouge">setInterval</code>返回的整数值是连续的，也就是说，第二个<code class="highlighter-rouge">setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1">// 10</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1">// 11</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1">// 12</span>
</code></pre></div></div>

<p>上面代码中，连续调用三次<code class="highlighter-rouge">setTimeout</code>，返回值都比上一次大了1。</p>

<p>利用这一点，可以写一个函数，取消当前所有的<code class="highlighter-rouge">setTimeout</code>定时器。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gid</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="nx">clearAllTimeouts</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nx">clearAllTimeouts</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">id</span> <span class="o">!==</span> <span class="nx">gid</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">id</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})();</span>
</code></pre></div></div>

<p>上面代码中，先调用<code class="highlighter-rouge">setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p>

<h2 id="实例debounce-函数">实例：debounce 函数</h2>

<p>有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">(</span><span class="s1">'textarea'</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s1">'keydown'</span><span class="p">,</span> <span class="nx">ajaxAction</span><span class="p">);</span>
</code></pre></div></div>

<p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发<code class="highlighter-rouge">keydown</code>事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的<code class="highlighter-rouge">keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的<code class="highlighter-rouge">keydown</code>事件，再将数据发送出去。</p>

<p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">(</span><span class="s1">'textarea'</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s1">'keydown'</span><span class="p">,</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">ajaxAction</span><span class="p">,</span> <span class="mi">2500</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 声明计时器</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="kr">arguments</span><span class="p">;</span>
    <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p>

<h2 id="运行机制">运行机制</h2>

<p><code class="highlighter-rouge">setTimeout</code>和<code class="highlighter-rouge">setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>

<p>这意味着，<code class="highlighter-rouge">setTimeout</code>和<code class="highlighter-rouge">setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code class="highlighter-rouge">setTimeout</code>和<code class="highlighter-rouge">setInterval</code>指定的任务，一定会按照预定时间执行。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">someTask</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="nx">veryLongTask</span><span class="p">();</span>
</code></pre></div></div>

<p>上面代码的<code class="highlighter-rouge">setTimeout</code>，指定100毫秒以后运行一个任务。但是，如果后面的<code class="highlighter-rouge">veryLongTask</code>函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的<code class="highlighter-rouge">someTask</code>就只有等着，等到<code class="highlighter-rouge">veryLongTask</code>运行结束，才轮到它执行。</p>

<p>再看一个<code class="highlighter-rouge">setInterval</code>的例子。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

<span class="nx">sleep</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="highlighter-rouge">setInterval</code>要求每隔1000毫秒，就输出一个2。但是，紧接着的<code class="highlighter-rouge">sleep</code>语句需要3000毫秒才能完成，那么<code class="highlighter-rouge">setInterval</code>就必须推迟到3000毫秒之后才开始生效。注意，生效后<code class="highlighter-rouge">setInterval</code>不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。</p>

<h2 id="settimeoutf-0">setTimeout(f, 0)</h2>

<h3 id="含义">含义</h3>

<p><code class="highlighter-rouge">setTimeout</code>的作用是将代码推迟到指定时间执行，如果指定时间为<code class="highlighter-rouge">0</code>，即<code class="highlighter-rouge">setTimeout(f, 0)</code>，那么会立刻执行吗？</p>

<p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行<code class="highlighter-rouge">setTimeout</code>指定的回调函数<code class="highlighter-rouge">f</code>。也就是说，<code class="highlighter-rouge">setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// 2</span>
<span class="c1">// 1</span>
</code></pre></div></div>

<p>上面代码先输出<code class="highlighter-rouge">2</code>，再输出<code class="highlighter-rouge">1</code>。因为<code class="highlighter-rouge">2</code>是同步任务，在本轮事件循环执行，而<code class="highlighter-rouge">1</code>是下一轮事件循环执行。</p>

<p>总之，<code class="highlighter-rouge">setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行<code class="highlighter-rouge">f</code>，但是并不能保证立刻就执行<code class="highlighter-rouge">f</code>。</p>

<h3 id="应用">应用</h3>

<p><code class="highlighter-rouge">setTimeout(f, 0)</code>有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到<code class="highlighter-rouge">setTimeout(f, 0)</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="button" id="myButton" value="click"&gt;</span>

<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'myButton'</span><span class="p">);</span>

<span class="nx">input</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span><span class="s1">' input'</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">};</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">C</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="s1">' body'</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上面代码在点击按钮后，先触发回调函数<code class="highlighter-rouge">A</code>，然后触发函数<code class="highlighter-rouge">C</code>。函数<code class="highlighter-rouge">A</code>中，<code class="highlighter-rouge">setTimeout</code>将函数<code class="highlighter-rouge">B</code>推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数<code class="highlighter-rouge">C</code>的目的了。</p>

<p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code class="highlighter-rouge">keypress</code>事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="text" id="input-box"&gt;</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'input-box'</span><span class="p">).</span><span class="nx">onkeypress</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code class="highlighter-rouge">this.value</code>取不到最新输入的那个字符。只有用<code class="highlighter-rouge">setTimeout</code>改写，上面的代码才能发挥作用。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'input-box'</span><span class="p">).</span><span class="nx">onkeypress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码将代码放入<code class="highlighter-rouge">setTimeout</code>之中，就能使得它在浏览器接收到文本之后触发。</p>

<p>由于<code class="highlighter-rouge">setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code class="highlighter-rouge">setTimeout(f, 0)</code>里面执行。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">'div'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// 写法一</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mh">0xA00000</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0xFFFFFF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="s1">'#'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">timer</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mh">0x100000</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="s1">'#'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">i</span><span class="o">++</span> <span class="o">==</span> <span class="mh">0xFFFFFF</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code class="highlighter-rouge">setTimeout(f, 0)</code>的好处。</p>

<p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code class="highlighter-rouge">setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li>Ilya Kantor, <a href="http://javascript.info/tutorial/settimeout-setinterval">Understanding timers: setTimeout and setInterval</a></li>
  <li>Ilya Kantor, <a href="http://javascript.info/tutorial/events-and-timing-depth">Events and timing in-depth</a></li>
  <li>MDN, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout">WindowTimers.setTimeout()</a></li>
  <li>Artem Tyurin, <a href="http://agentcooper.ghost.io/being-evil-with-settimeout/">Being evil with setTimeout</a></li>
  <li>Jake Archibald, <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
  <li>Tamas Kadlecsik, <a href="https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/">Node.js at Scale - Understanding the Node.js Event Loop</a></li>
</ul>


</article>

<div class="row">
<div class="twelve columns">

<h2>留言</h2>

<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>

</div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="/introduction/license.html">版权声明</a> | last modified on 2014-10-12 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>
</body>
</html>


